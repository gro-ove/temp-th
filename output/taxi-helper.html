<!DOCTYPE html><html style="background:black"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="mobile-web-app-capable" content="yes"><title>Такси-Помощник</title><style>/* values */
/* mixins */
/* main */
html {
  background: #50514f !important;
}
body {
  background: #50514f;
  color: white;
  margin: 0;
  font-size: 16px;
  height: 100%;
  min-width: 300px;
  min-height: 400px;
}
body,
button,
input,
select,
textarea {
  font-family: 'Roboto', sans-serif;
}
/* global */
h1,
h2,
h3,
h4,
h5,
h6,
button,
.a_as_button {
  font-weight: 400;
  font-family: 'Roboto Condensed', sans-serif;
  margin: 12px 0;
}
h5,
h6,
button,
.a_as_button {
  text-transform: uppercase;
}
h5,
h6 {
  font-weight: 700;
}
h6 {
  font-size: 80%;
  opacity: .7;
}
a {
  text-decoration: none;
  color: inherit;
}
button,
.a_as_button {
  text-decoration: none;
  color: inherit;
  background: #70c1a3;
  color: #ffffff;
  display: block;
  border: none;
  outline: none;
  border-radius: 2px;
  padding: 8px 4px;
  margin: 10px 0 13px;
  font-size: 16px;
  box-shadow: 0 3px #3d8e70, 0 3px 6px rgba(0, 0, 0, 0.2);
  width: 100%;
  box-sizing: border-box;
}
button:hover,
.a_as_button:hover {
  background: #69be9e;
}
button:active,
.a_as_button:active {
  position: relative;
  top: 1px;
  box-shadow: 0 2px #3d8e70, 0 2px 5px rgba(0, 0, 0, 0.4);
}
button.important,
.a_as_button.important {
  background: #c1b370;
  color: #ffffff;
  box-shadow: 0 3px #8e803d, 0 3px 6px rgba(0, 0, 0, 0.2);
}
button.important:hover,
.a_as_button.important:hover {
  background: #beaf69;
}
button.important:active,
.a_as_button.important:active {
  box-shadow: 0 2px #8e803d, 0 2px 5px rgba(0, 0, 0, 0.4);
}
button.finish,
.a_as_button.finish {
  background: #d18370;
  color: #ffffff;
  box-shadow: 0 3px #a64b35, 0 3px 6px rgba(0, 0, 0, 0.2);
}
button.finish:hover,
.a_as_button.finish:hover {
  background: #cf7c68;
}
button.finish:active,
.a_as_button.finish:active {
  box-shadow: 0 2px #a64b35, 0 2px 5px rgba(0, 0, 0, 0.4);
}
.button_circle {
  background: #70c1a3;
  color: #ffffff;
  margin: 0 0 15px;
  padding: 15px;
  border-radius: 100%;
  width: 56px;
  height: 56px;
  line-height: 26px;
  box-shadow: 0 1px 5px rgba(0, 0, 0, 0.28);
  box-shadow: 0 3px 6px rgba(0, 0, 0, 0.2) !important;
}
.button_circle:active {
  position: static;
  top: auto;
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.22) !important;
}
.div_progressbar {
  background: rgba(0, 0, 0, 0.36);
  height: 5px;
  width: 100%;
  position: relative;
  display: block;
  margin: 10px 0;
}
.div_progressbar_level {
  background: #70c1a3;
  color: #ffffff;
  width: 0%;
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0;
  transition: width .2s linear;
  -webkit-transition: width .2s linear;
}
input,
select {
  font-size: 16px;
  padding: 4px;
  box-sizing: border-box;
  outline: none;
  width: 100%;
}
.p_small {
  opacity: .7;
  font-size: 80%;
}
.halfwidth {
  width: 49%;
  display: inline-block;
}
.halfwidth + .halfwidth {
  margin-left: 2%;
}
/* dialog */
.dialog_wrapper {
  position: fixed;
  background: rgba(0, 0, 0, 0.36);
  border-radius: 0;
  border: none;
  display: table;
  left: 0;
  right: 0;
  top: 0;
  bottom: 0;
  height: 100%;
  width: 100%;
  padding: 0;
  z-index: 11;
  padding: 28px;
  box-sizing: border-box;
}
.dialog_vertical_align {
  display: table-cell;
  text-align: center;
  vertical-align: middle;
}
.dialog_inner {
  text-align: left;
  background: #ffffff;
  color: #000000;
  border-radius: 0;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.27);
  padding: 10px 20px 10px;
  box-sizing: border-box;
  border-radius: 2px;
}
.dialog_header h5 {
  margin-top: 10px;
}
.dialog_content p {
  margin-bottom: 5px;
}
/* top bar */
#ui_tabbar {
  background: #70c1a3;
  color: #ffffff;
  line-height: 56px;
  font-size: 18px;
  height: 56px;
  box-shadow: 0px 1px 4px rgba(0, 0, 0, 0.3);
  position: relative;
  z-index: 11;
}
#ui_tabbar_btn_menu {
  display: inline-block;
  background: url(img/ic_menu.png) no-repeat center;
  background-size: 26px;
  width: 60px;
  height: 100%;
  vertical-align: bottom;
  margin-right: -6px;
}
.ui_tabbar_tab {
  display: inline-block;
  box-sizing: border-box;
  height: 56px;
  padding: 0 16px;
}
.ui_tabbar_tab_active {
  border-bottom: 5px solid white;
}
#ui_menu {
  content: "";
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: transparent;
  z-index: 10;
  pointer-events: none;
  transition: background .3s;
  -webkit-transition: background .3s;
  transform: translate3d(0, 0, 0);
  -webkit-transform: translate3d(0, 0, 0);
}
#ui_menu.ui_menu_active {
  pointer-events: all;
  background: rgba(0, 0, 0, 0.3);
}
#ui_menu.ui_menu_active #ui_menu_content {
  left: 0;
}
#ui_menu_content {
  position: absolute;
  top: 56px;
  left: -240px;
  width: 240px;
  bottom: 0;
  background: #ffffff;
  color: #000000;
  font-size: 16px;
  transition: left .3s;
  -webkit-transition: left .3s;
  z-index: 10;
  box-shadow: 1px 0px 4px rgba(0, 0, 0, 0.3);
  padding: 8px 12px;
  box-sizing: border-box;
}
.ui_menu_item {
  font-size: 16px;
  padding: 8px 8px;
  box-sizing: border-box;
  outline: none;
  width: 100%;
  border: none;
  border-radius: 0;
  background: transparent;
  color: #000000;
  box-shadow: none !important;
  margin: 0 !important;
  text-align: left;
}
.ui_menu_item:disabled {
  opacity: 0.3;
}
.ui_menu_item:hover,
.ui_menu_item:active {
  background: #e6e6e6;
}
/* content */
.div_section {
  display: block;
  margin: 10px 20px;
  position: absolute;
  top: 56px;
  bottom: -100px;
  left: 0;
  right: 0;
  box-sizing: border-box;
  min-width: 300px;
}
.section_footer {
  position: absolute;
  left: 0;
  right: 0;
  bottom: 0;
}
hr {
  border: none;
  border-top: 2px solid rgba(0, 0, 0, 0.36);
}
.div_sum_entry {
  margin-bottom: 3px;
  font-size: 90%;
}
.div_sum_entry:after {
  float: right;
  content: attr(data-value);
  font-weight: 700;
}
.div_sum_entry_money:after {
  content: attr(data-value) " ₽";
  color: #40b153;
}
.div_sum_entry_money[data-value^="-"]:after {
  color: #b14053;
}
.line-legend {
  list-style-type: none;
}
.line-legend li {
  display: inline-block;
  width: 100px;
}
.line-legend span {
  display: inline-block;
  width: 12px;
  height: 12px;
  border-radius: 0;
  border: none;
  margin-right: 8px;
}
/* partial stuff */
#section_edit_init_img {
  background: url(img/title.jpg) no-repeat center;
  background-size: cover;
  /*height: 446px;
        margin: -20px -20px 0 -20px;*/
  position: absolute;
  top: -10px;
  left: -20px;
  right: -20px;
  bottom: 120px;
}
#section_edit_add_job {
  position: absolute;
  top: auto;
  bottom: 85px;
  right: 0px;
  z-index: 1;
  background-image: url(img/ic_add.png);
  background-repeat: no-repeat;
  background-position: center;
  background-size: 26px;
}
#section_edit_jobs_list {
  counter-reset: shift_entry_count;
  overflow-y: auto;
}
.section_edit_job_entry {
  position: relative;
  margin: 25px 0 25px 40px;
}
.section_edit_job_entry:before {
  counter-increment: job_entry_count;
  content: counter(job_entry_count) ". ";
  position: absolute;
  top: 0;
  left: -45px;
  width: 40px;
  text-align: right;
}
.section_edit_job_entry p {
  margin: 3px 0;
}
#section_view_view_mode {
  width: 100%;
  margin: 0;
  padding: 0;
  background: transparent;
  position: absolute;
  top: 8px;
  border: none;
  outline: none;
  right: 0;
  -webkit-appearance: none;
  background: url(img/ic_expand_more.png) no-repeat right transparent;
}
#section_view_view:after {
  pointer-events: none;
  position: absolute;
  content: "";
  background: #50514f;
  z-index: 1;
  top: 0;
  left: 0;
  right: 30px;
  height: 30px;
}
#section_view_shifts_number {
  pointer-events: none;
  position: relative;
  z-index: 2;
}
#section_view_stats h6,
#section_view_charts h6 {
  margin-top: 30px;
}
#section_view_shifts_list {
  counter-reset: shift_entry_count;
  overflow-y: auto;
}
.section_view_shift_entry {
  position: relative;
  margin: 25px 0 25px 40px;
}
.section_view_shift_entry:before {
  counter-increment: shift_entry_count;
  content: counter(shift_entry_count) ". ";
  position: absolute;
  top: 0;
  left: -45px;
  width: 40px;
  text-align: right;
}
.section_view_shift_entry p {
  margin: 3px 0;
}
canvas {
  margin-left: 0px;
  margin-right: 0px;
}</style><link href='http://fonts.googleapis.com/css?family=Roboto:400,300&subset=latin,cyrillic,cyrillic-ext,latin-ext' rel='stylesheet' type='text/css'><link href='http://fonts.googleapis.com/css?family=Roboto+Condensed:700,400&subset=latin,cyrillic,cyrillic-ext,latin-ext' rel='stylesheet' type='text/css'><script>/*!
 * Chart.js
 * http://chartjs.org/
 * Version: 1.0.2
 *
 * Copyright 2015 Nick Downie
 * Released under the MIT license
 * https://github.com/nnnick/Chart.js/blob/master/LICENSE.md
 */


(function(){

	"use strict";

	//Declare root variable - window in the browser, global on the server
	var root = this,
		previous = root.Chart;

	//Occupy the global variable of Chart, and create a simple base class
	var Chart = function(context){
		var chart = this;
		this.canvas = context.canvas;

		this.ctx = context;

		//Variables global to the chart
		var computeDimension = function(element,dimension)
		{
			if (element['offset'+dimension])
			{
				return element['offset'+dimension];
			}
			else
			{
				return document.defaultView.getComputedStyle(element).getPropertyValue(dimension);
			}
		}

		var width = this.width = computeDimension(context.canvas,'Width');
		var height = this.height = computeDimension(context.canvas,'Height');

		// Firefox requires this to work correctly
		context.canvas.width  = width;
		context.canvas.height = height;

		var width = this.width = context.canvas.width;
		var height = this.height = context.canvas.height;
		this.aspectRatio = this.width / this.height;
		//High pixel density displays - multiply the size of the canvas height/width by the device pixel ratio, then scale.
		helpers.retinaScale(this);

		return this;
	};
	//Globally expose the defaults to allow for user updating/changing
	Chart.defaults = {
		global: {
			// Boolean - If we should show the scale at all
			showScale: true,

			// Boolean - If we want to override with a hard coded scale
			scaleOverride: false,

			// ** Required if scaleOverride is true **
			// Number - The number of steps in a hard coded scale
			scaleSteps: null,
			// Number - The value jump in the hard coded scale
			scaleStepWidth: null,
			// Number - The scale starting value
			scaleStartValue: null,

			// String - Colour of the scale line
			scaleLineColor: "rgba(0,0,0,.1)",

			// Number - Pixel width of the scale line
			scaleLineWidth: 1,

			// Boolean - Whether to show labels on the scale
			scaleShowLabels: true,

			// Interpolated JS string - can access value
			scaleLabel: "<%=value%>",

			// Boolean - Whether the scale should stick to integers, and not show any floats even if drawing space is there
			scaleIntegersOnly: true,

			// Boolean - Whether the scale should start at zero, or an order of magnitude down from the lowest value
			scaleBeginAtZero: false,

			// String - Scale label font declaration for the scale label
			scaleFontFamily: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",

			// Number - Scale label font size in pixels
			scaleFontSize: 12,

			// String - Scale label font weight style
			scaleFontStyle: "normal",

			// String - Scale label font colour
			scaleFontColor: "#666",

			// Boolean - whether or not the chart should be responsive and resize when the browser does.
			responsive: false,

			// Boolean - whether to maintain the starting aspect ratio or not when responsive, if set to false, will take up entire container
			maintainAspectRatio: true,

			// Boolean - Determines whether to draw tooltips on the canvas or not - attaches events to touchmove & mousemove
			showTooltips: true,

			// Boolean - Determines whether to draw built-in tooltip or call custom tooltip function
			customTooltips: false,

			// Array - Array of string names to attach tooltip events
			tooltipEvents: ["mousemove", "touchstart", "touchmove", "mouseout"],

			// String - Tooltip background colour
			tooltipFillColor: "rgba(0,0,0,0.8)",

			// String - Tooltip label font declaration for the scale label
			tooltipFontFamily: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",

			// Number - Tooltip label font size in pixels
			tooltipFontSize: 14,

			// String - Tooltip font weight style
			tooltipFontStyle: "normal",

			// String - Tooltip label font colour
			tooltipFontColor: "#fff",

			// String - Tooltip title font declaration for the scale label
			tooltipTitleFontFamily: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",

			// Number - Tooltip title font size in pixels
			tooltipTitleFontSize: 14,

			// String - Tooltip title font weight style
			tooltipTitleFontStyle: "bold",

			// String - Tooltip title font colour
			tooltipTitleFontColor: "#fff",

			// Number - pixel width of padding around tooltip text
			tooltipYPadding: 6,

			// Number - pixel width of padding around tooltip text
			tooltipXPadding: 6,

			// Number - Size of the caret on the tooltip
			tooltipCaretSize: 8,

			// Number - Pixel radius of the tooltip border
			tooltipCornerRadius: 6,

			// Number - Pixel offset from point x to tooltip edge
			tooltipXOffset: 10,

			// String - Template string for single tooltips
			tooltipTemplate: "<%if (label){%><%=label%>: <%}%><%= value %>",

			// String - Template string for single tooltips
			multiTooltipTemplate: "<%= value %>",

			// String - Colour behind the legend colour block
			multiTooltipKeyBackground: '#fff',
		}
	};

	//Create a dictionary of chart types, to allow for extension of existing types
	Chart.types = {};

	//Global Chart helpers object for utility methods and classes
	var helpers = Chart.helpers = {};

		//-- Basic js utility methods
	var each = helpers.each = function(loopable,callback,self){
			var additionalArgs = Array.prototype.slice.call(arguments, 3);
			// Check to see if null or undefined firstly.
			if (loopable){
				if (loopable.length === +loopable.length){
					var i;
					for (i=0; i<loopable.length; i++){
						callback.apply(self,[loopable[i], i].concat(additionalArgs));
					}
				}
				else{
					for (var item in loopable){
						callback.apply(self,[loopable[item],item].concat(additionalArgs));
					}
				}
			}
		},
		clone = helpers.clone = function(obj){
			var objClone = {};
			each(obj,function(value,key){
				if (obj.hasOwnProperty(key)) objClone[key] = value;
			});
			return objClone;
		},
		extend = helpers.extend = function(base){
			each(Array.prototype.slice.call(arguments,1), function(extensionObject) {
				each(extensionObject,function(value,key){
					if (extensionObject.hasOwnProperty(key)) base[key] = value;
				});
			});
			return base;
		},
		merge = helpers.merge = function(base,master){
			//Merge properties in left object over to a shallow clone of object right.
			var args = Array.prototype.slice.call(arguments,0);
			args.unshift({});
			return extend.apply(null, args);
		},
		indexOf = helpers.indexOf = function(arrayToSearch, item){
			if (Array.prototype.indexOf) {
				return arrayToSearch.indexOf(item);
			}
			else{
				for (var i = 0; i < arrayToSearch.length; i++) {
					if (arrayToSearch[i] === item) return i;
				}
				return -1;
			}
		},
		where = helpers.where = function(collection, filterCallback){
			var filtered = [];

			helpers.each(collection, function(item){
				if (filterCallback(item)){
					filtered.push(item);
				}
			});

			return filtered;
		},
		findNextWhere = helpers.findNextWhere = function(arrayToSearch, filterCallback, startIndex){
			// Default to start of the array
			if (!startIndex){
				startIndex = -1;
			}
			for (var i = startIndex + 1; i < arrayToSearch.length; i++) {
				var currentItem = arrayToSearch[i];
				if (filterCallback(currentItem)){
					return currentItem;
				}
			}
		},
		findPreviousWhere = helpers.findPreviousWhere = function(arrayToSearch, filterCallback, startIndex){
			// Default to end of the array
			if (!startIndex){
				startIndex = arrayToSearch.length;
			}
			for (var i = startIndex - 1; i >= 0; i--) {
				var currentItem = arrayToSearch[i];
				if (filterCallback(currentItem)){
					return currentItem;
				}
			}
		},
		inherits = helpers.inherits = function(extensions){
			//Basic javascript inheritance based on the model created in Backbone.js
			var parent = this;
			var ChartElement = (extensions && extensions.hasOwnProperty("constructor")) ? extensions.constructor : function(){ return parent.apply(this, arguments); };

			var Surrogate = function(){ this.constructor = ChartElement;};
			Surrogate.prototype = parent.prototype;
			ChartElement.prototype = new Surrogate();

			ChartElement.extend = inherits;

			if (extensions) extend(ChartElement.prototype, extensions);

			ChartElement.__super__ = parent.prototype;

			return ChartElement;
		},
		noop = helpers.noop = function(){},
		uid = helpers.uid = (function(){
			var id=0;
			return function(){
				return "chart-" + id++;
			};
		})(),
		warn = helpers.warn = function(str){
			//Method for warning of errors
			if (window.console && typeof window.console.warn == "function") console.warn(str);
		},
		amd = helpers.amd = (typeof define == 'function' && define.amd),
		//-- Math methods
		isNumber = helpers.isNumber = function(n){
			return !isNaN(parseFloat(n)) && isFinite(n);
		},
		max = helpers.max = function(array){
			return Math.max.apply( Math, array );
		},
		min = helpers.min = function(array){
			return Math.min.apply( Math, array );
		},
		cap = helpers.cap = function(valueToCap,maxValue,minValue){
			if(isNumber(maxValue)) {
				if( valueToCap > maxValue ) {
					return maxValue;
				}
			}
			else if(isNumber(minValue)){
				if ( valueToCap < minValue ){
					return minValue;
				}
			}
			return valueToCap;
		},
		getDecimalPlaces = helpers.getDecimalPlaces = function(num){
			if (num%1!==0 && isNumber(num)){
				return num.toString().split(".")[1].length;
			}
			else {
				return 0;
			}
		},
		toRadians = helpers.radians = function(degrees){
			return degrees * (Math.PI/180);
		},
		// Gets the angle from vertical upright to the point about a centre.
		getAngleFromPoint = helpers.getAngleFromPoint = function(centrePoint, anglePoint){
			var distanceFromXCenter = anglePoint.x - centrePoint.x,
				distanceFromYCenter = anglePoint.y - centrePoint.y,
				radialDistanceFromCenter = Math.sqrt( distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);


			var angle = Math.PI * 2 + Math.atan2(distanceFromYCenter, distanceFromXCenter);

			//If the segment is in the top left quadrant, we need to add another rotation to the angle
			if (distanceFromXCenter < 0 && distanceFromYCenter < 0){
				angle += Math.PI*2;
			}

			return {
				angle: angle,
				distance: radialDistanceFromCenter
			};
		},
		aliasPixel = helpers.aliasPixel = function(pixelWidth){
			return (pixelWidth % 2 === 0) ? 0 : 0.5;
		},
		splineCurve = helpers.splineCurve = function(FirstPoint,MiddlePoint,AfterPoint,t){
			//Props to Rob Spencer at scaled innovation for his post on splining between points
			//http://scaledinnovation.com/analytics/splines/aboutSplines.html
			var d01=Math.sqrt(Math.pow(MiddlePoint.x-FirstPoint.x,2)+Math.pow(MiddlePoint.y-FirstPoint.y,2)),
				d12=Math.sqrt(Math.pow(AfterPoint.x-MiddlePoint.x,2)+Math.pow(AfterPoint.y-MiddlePoint.y,2)),
				fa=t*d01/(d01+d12),// scaling factor for triangle Ta
				fb=t*d12/(d01+d12);
			return {
				inner : {
					x : MiddlePoint.x-fa*(AfterPoint.x-FirstPoint.x),
					y : MiddlePoint.y-fa*(AfterPoint.y-FirstPoint.y)
				},
				outer : {
					x: MiddlePoint.x+fb*(AfterPoint.x-FirstPoint.x),
					y : MiddlePoint.y+fb*(AfterPoint.y-FirstPoint.y)
				}
			};
		},
		calculateOrderOfMagnitude = helpers.calculateOrderOfMagnitude = function(val){
			return Math.floor(Math.log(val) / Math.LN10);
		},
		calculateScaleRange = helpers.calculateScaleRange = function(valuesArray, drawingSize, textSize, startFromZero, integersOnly){

			//Set a minimum step of two - a point at the top of the graph, and a point at the base
			var minSteps = 2,
				maxSteps = Math.floor(drawingSize/(textSize * 1.5)),
				skipFitting = (minSteps >= maxSteps);

			var maxValue = max(valuesArray),
				minValue = min(valuesArray);

			// We need some degree of seperation here to calculate the scales if all the values are the same
			// Adding/minusing 0.5 will give us a range of 1.
			if (maxValue === minValue){
				maxValue += 0.5;
				// So we don't end up with a graph with a negative start value if we've said always start from zero
				if (minValue >= 0.5 && !startFromZero){
					minValue -= 0.5;
				}
				else{
					// Make up a whole number above the values
					maxValue += 0.5;
				}
			}

			var	valueRange = Math.abs(maxValue - minValue),
				rangeOrderOfMagnitude = calculateOrderOfMagnitude(valueRange),
				graphMax = Math.ceil(maxValue / (1 * Math.pow(10, rangeOrderOfMagnitude))) * Math.pow(10, rangeOrderOfMagnitude),
				graphMin = (startFromZero) ? 0 : Math.floor(minValue / (1 * Math.pow(10, rangeOrderOfMagnitude))) * Math.pow(10, rangeOrderOfMagnitude),
				graphRange = graphMax - graphMin,
				stepValue = Math.pow(10, rangeOrderOfMagnitude),
				numberOfSteps = Math.round(graphRange / stepValue);

			//If we have more space on the graph we'll use it to give more definition to the data
			while((numberOfSteps > maxSteps || (numberOfSteps * 2) < maxSteps) && !skipFitting) {
				if(numberOfSteps > maxSteps){
					stepValue *=2;
					numberOfSteps = Math.round(graphRange/stepValue);
					// Don't ever deal with a decimal number of steps - cancel fitting and just use the minimum number of steps.
					if (numberOfSteps % 1 !== 0){
						skipFitting = true;
					}
				}
				//We can fit in double the amount of scale points on the scale
				else{
					//If user has declared ints only, and the step value isn't a decimal
					if (integersOnly && rangeOrderOfMagnitude >= 0){
						//If the user has said integers only, we need to check that making the scale more granular wouldn't make it a float
						if(stepValue/2 % 1 === 0){
							stepValue /=2;
							numberOfSteps = Math.round(graphRange/stepValue);
						}
						//If it would make it a float break out of the loop
						else{
							break;
						}
					}
					//If the scale doesn't have to be an int, make the scale more granular anyway.
					else{
						stepValue /=2;
						numberOfSteps = Math.round(graphRange/stepValue);
					}

				}
			}

			if (skipFitting){
				numberOfSteps = minSteps;
				stepValue = graphRange / numberOfSteps;
			}

			return {
				steps : numberOfSteps,
				stepValue : stepValue,
				min : graphMin,
				max	: graphMin + (numberOfSteps * stepValue)
			};

		},
		/* jshint ignore:start */
		// Blows up jshint errors based on the new Function constructor
		//Templating methods
		//Javascript micro templating by John Resig - source at http://ejohn.org/blog/javascript-micro-templating/
		template = helpers.template = function(templateString, valuesObject){

			// If templateString is function rather than string-template - call the function for valuesObject

			if(templateString instanceof Function){
			 	return templateString(valuesObject);
		 	}

			var cache = {};
			function tmpl(str, data){
				// Figure out if we're getting a template, or if we need to
				// load the template - and be sure to cache the result.
				var fn = !/\W/.test(str) ?
				cache[str] = cache[str] :

				// Generate a reusable function that will serve as a template
				// generator (and which will be cached).
				new Function("obj",
					"var p=[],print=function(){p.push.apply(p,arguments);};" +

					// Introduce the data as local variables using with(){}
					"with(obj){p.push('" +

					// Convert the template into pure JavaScript
					str
						.replace(/[\r\t\n]/g, " ")
						.split("<%").join("\t")
						.replace(/((^|%>)[^\t]*)'/g, "$1\r")
						.replace(/\t=(.*?)%>/g, "',$1,'")
						.split("\t").join("');")
						.split("%>").join("p.push('")
						.split("\r").join("\\'") +
					"');}return p.join('');"
				);

				// Provide some basic currying to the user
				return data ? fn( data ) : fn;
			}
			return tmpl(templateString,valuesObject);
		},
		/* jshint ignore:end */
		generateLabels = helpers.generateLabels = function(templateString,numberOfSteps,graphMin,stepValue){
			var labelsArray = new Array(numberOfSteps);
			if (labelTemplateString){
				each(labelsArray,function(val,index){
					labelsArray[index] = template(templateString,{value: (graphMin + (stepValue*(index+1)))});
				});
			}
			return labelsArray;
		},
		//-- DOM methods
		getRelativePosition = helpers.getRelativePosition = function(evt){
			var mouseX, mouseY;
			var e = evt.originalEvent || evt,
				canvas = evt.currentTarget || evt.srcElement,
				boundingRect = canvas.getBoundingClientRect();

			if (e.touches){
				mouseX = e.touches[0].clientX - boundingRect.left;
				mouseY = e.touches[0].clientY - boundingRect.top;

			}
			else{
				mouseX = e.clientX - boundingRect.left;
				mouseY = e.clientY - boundingRect.top;
			}

			return {
				x : mouseX,
				y : mouseY
			};

		},
		addEvent = helpers.addEvent = function(node,eventType,method){
			if (node.addEventListener){
				node.addEventListener(eventType,method);
			} else if (node.attachEvent){
				node.attachEvent("on"+eventType, method);
			} else {
				node["on"+eventType] = method;
			}
		},
		removeEvent = helpers.removeEvent = function(node, eventType, handler){
			if (node.removeEventListener){
				node.removeEventListener(eventType, handler, false);
			} else if (node.detachEvent){
				node.detachEvent("on"+eventType,handler);
			} else{
				node["on" + eventType] = noop;
			}
		},
		bindEvents = helpers.bindEvents = function(chartInstance, arrayOfEvents, handler){
			// Create the events object if it's not already present
			if (!chartInstance.events) chartInstance.events = {};

			each(arrayOfEvents,function(eventName){
				chartInstance.events[eventName] = function(){
					handler.apply(chartInstance, arguments);
				};
				addEvent(chartInstance.chart.canvas,eventName,chartInstance.events[eventName]);
			});
		},
		unbindEvents = helpers.unbindEvents = function (chartInstance, arrayOfEvents) {
			each(arrayOfEvents, function(handler,eventName){
				removeEvent(chartInstance.chart.canvas, eventName, handler);
			});
		},
		getMaximumWidth = helpers.getMaximumWidth = function(domNode){
			var container = domNode.parentNode;
			// TODO = check cross browser stuff with this.
			return container.clientWidth;
		},
		getMaximumHeight = helpers.getMaximumHeight = function(domNode){
			var container = domNode.parentNode;
			// TODO = check cross browser stuff with this.
			return container.clientHeight;
		},
		getMaximumSize = helpers.getMaximumSize = helpers.getMaximumWidth, // legacy support
		retinaScale = helpers.retinaScale = function(chart){
			var ctx = chart.ctx,
				width = chart.canvas.width,
				height = chart.canvas.height;

			if (window.devicePixelRatio) {
				ctx.canvas.style.width = width + "px";
				ctx.canvas.style.height = height + "px";
				ctx.canvas.height = height * window.devicePixelRatio;
				ctx.canvas.width = width * window.devicePixelRatio;
				ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
			}
		},
		//-- Canvas methods
		clear = helpers.clear = function(chart){
			chart.ctx.clearRect(0,0,chart.width,chart.height);
		},
		fontString = helpers.fontString = function(pixelSize,fontStyle,fontFamily){
			return fontStyle + " " + pixelSize+"px " + fontFamily;
		},
		longestText = helpers.longestText = function(ctx,font,arrayOfStrings){
			ctx.font = font;
			var longest = 0;
			each(arrayOfStrings,function(string){
				var textWidth = ctx.measureText(string).width;
				longest = (textWidth > longest) ? textWidth : longest;
			});
			return longest;
		},
		drawRoundedRectangle = helpers.drawRoundedRectangle = function(ctx,x,y,width,height,radius){
			ctx.beginPath();
			ctx.moveTo(x + radius, y);
			ctx.lineTo(x + width - radius, y);
			ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
			ctx.lineTo(x + width, y + height - radius);
			ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
			ctx.lineTo(x + radius, y + height);
			ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
			ctx.lineTo(x, y + radius);
			ctx.quadraticCurveTo(x, y, x + radius, y);
			ctx.closePath();
		};


	//Store a reference to each instance - allowing us to globally resize chart instances on window resize.
	//Destroy method on the chart will remove the instance of the chart from this reference.
	Chart.instances = {};

	Chart.Type = function(data,options,chart){
		this.options = options;
		this.chart = chart;
		this.id = uid();
		//Add the chart instance to the global namespace
		Chart.instances[this.id] = this;

		// Initialize is always called when a chart type is created
		// By default it is a no op, but it should be extended
		if (options.responsive){
			this.resize();
		}
		this.initialize.call(this,data);
	};

	//Core methods that'll be a part of every chart type
	extend(Chart.Type.prototype,{
		initialize : function(){return this;},
		clear : function(){
			clear(this.chart);
			return this;
		},
		stop : function(){
			return this;
		},
		resize : function(callback){
			this.stop();
			var canvas = this.chart.canvas,
				newWidth = getMaximumWidth(this.chart.canvas),
				newHeight = this.options.maintainAspectRatio ? newWidth / this.chart.aspectRatio : getMaximumHeight(this.chart.canvas);

			canvas.width = this.chart.width = newWidth;
			canvas.height = this.chart.height = newHeight;

			retinaScale(this.chart);

			if (typeof callback === "function"){
				callback.apply(this, Array.prototype.slice.call(arguments, 1));
			}
			return this;
		},
		reflow : noop,
		render : function(reflow){
			if (reflow){
				this.reflow();
			}

			this.draw();
			return this;
		},
		generateLegend : function(){
			return template(this.options.legendTemplate,this);
		},
		destroy : function(){
			this.clear();
			unbindEvents(this, this.events);
			var canvas = this.chart.canvas;

			// Reset canvas height/width attributes starts a fresh with the canvas context
			canvas.width = this.chart.width;
			canvas.height = this.chart.height;

			// < IE9 doesn't support removeProperty
			if (canvas.style.removeProperty) {
				canvas.style.removeProperty('width');
				canvas.style.removeProperty('height');
			} else {
				canvas.style.removeAttribute('width');
				canvas.style.removeAttribute('height');
			}

			delete Chart.instances[this.id];
		},
		showTooltip : function(ChartElements, forceRedraw){
			// Only redraw the chart if we've actually changed what we're hovering on.
			if (typeof this.activeElements === 'undefined') this.activeElements = [];

			var isChanged = (function(Elements){
				var changed = false;

				if (Elements.length !== this.activeElements.length){
					changed = true;
					return changed;
				}

				each(Elements, function(element, index){
					if (element !== this.activeElements[index]){
						changed = true;
					}
				}, this);
				return changed;
			}).call(this, ChartElements);

			if (!isChanged && !forceRedraw){
				return;
			}
			else{
				this.activeElements = ChartElements;
			}
			this.draw();
			if(this.options.customTooltips){
				this.options.customTooltips(false);
			}
			if (ChartElements.length > 0){
				// If we have multiple datasets, show a MultiTooltip for all of the data points at that index
				if (this.datasets && this.datasets.length > 1) {
					var dataArray,
						dataIndex;

					for (var i = this.datasets.length - 1; i >= 0; i--) {
						dataArray = this.datasets[i].points || this.datasets[i].bars || this.datasets[i].segments;
						dataIndex = indexOf(dataArray, ChartElements[0]);
						if (dataIndex !== -1){
							break;
						}
					}
					var tooltipLabels = [],
						tooltipColors = [],
						medianPosition = (function(index) {

							// Get all the points at that particular index
							var Elements = [],
								dataCollection,
								xPositions = [],
								yPositions = [],
								xMax,
								yMax,
								xMin,
								yMin;
							helpers.each(this.datasets, function(dataset){
								dataCollection = dataset.points || dataset.bars || dataset.segments;
								if (dataCollection[dataIndex] && dataCollection[dataIndex].hasValue()){
									Elements.push(dataCollection[dataIndex]);
								}
							});

							helpers.each(Elements, function(element) {
								xPositions.push(element.x);
								yPositions.push(element.y);


								//Include any colour information about the element
								tooltipLabels.push(helpers.template(this.options.multiTooltipTemplate, element));
								tooltipColors.push({
									fill: element._saved.fillColor || element.fillColor,
									stroke: element._saved.strokeColor || element.strokeColor
								});

							}, this);

							yMin = min(yPositions);
							yMax = max(yPositions);

							xMin = min(xPositions);
							xMax = max(xPositions);

							return {
								x: (xMin > this.chart.width/2) ? xMin : xMax,
								y: (yMin + yMax)/2
							};
						}).call(this, dataIndex);

					new Chart.MultiTooltip({
						x: medianPosition.x,
						y: medianPosition.y,
						xPadding: this.options.tooltipXPadding,
						yPadding: this.options.tooltipYPadding,
						xOffset: this.options.tooltipXOffset,
						fillColor: this.options.tooltipFillColor,
						textColor: this.options.tooltipFontColor,
						fontFamily: this.options.tooltipFontFamily,
						fontStyle: this.options.tooltipFontStyle,
						fontSize: this.options.tooltipFontSize,
						titleTextColor: this.options.tooltipTitleFontColor,
						titleFontFamily: this.options.tooltipTitleFontFamily,
						titleFontStyle: this.options.tooltipTitleFontStyle,
						titleFontSize: this.options.tooltipTitleFontSize,
						cornerRadius: this.options.tooltipCornerRadius,
						labels: tooltipLabels,
						legendColors: tooltipColors,
						legendColorBackground : this.options.multiTooltipKeyBackground,
						title: ChartElements[0].label,
						chart: this.chart,
						ctx: this.chart.ctx,
						custom: this.options.customTooltips
					}).draw();

				} else {
					each(ChartElements, function(Element) {
						var tooltipPosition = Element.tooltipPosition();
						new Chart.Tooltip({
							x: Math.round(tooltipPosition.x),
							y: Math.round(tooltipPosition.y),
							xPadding: this.options.tooltipXPadding,
							yPadding: this.options.tooltipYPadding,
							fillColor: this.options.tooltipFillColor,
							textColor: this.options.tooltipFontColor,
							fontFamily: this.options.tooltipFontFamily,
							fontStyle: this.options.tooltipFontStyle,
							fontSize: this.options.tooltipFontSize,
							caretHeight: this.options.tooltipCaretSize,
							cornerRadius: this.options.tooltipCornerRadius,
							text: template(this.options.tooltipTemplate, Element),
							chart: this.chart,
							custom: this.options.customTooltips
						}).draw();
					}, this);
				}
			}
			return this;
		},
		toBase64Image : function(){
			return this.chart.canvas.toDataURL.apply(this.chart.canvas, arguments);
		}
	});

	Chart.Type.extend = function(extensions){

		var parent = this;

		var ChartType = function(){
			return parent.apply(this,arguments);
		};

		//Copy the prototype object of the this class
		ChartType.prototype = clone(parent.prototype);
		//Now overwrite some of the properties in the base class with the new extensions
		extend(ChartType.prototype, extensions);

		ChartType.extend = Chart.Type.extend;

		if (extensions.name || parent.prototype.name){

			var chartName = extensions.name || parent.prototype.name;
			//Assign any potential default values of the new chart type

			//If none are defined, we'll use a clone of the chart type this is being extended from.
			//I.e. if we extend a line chart, we'll use the defaults from the line chart if our new chart
			//doesn't define some defaults of their own.

			var baseDefaults = (Chart.defaults[parent.prototype.name]) ? clone(Chart.defaults[parent.prototype.name]) : {};

			Chart.defaults[chartName] = extend(baseDefaults,extensions.defaults);

			Chart.types[chartName] = ChartType;

			//Register this new chart type in the Chart prototype
			Chart.prototype[chartName] = function(data,options){
				var config = merge(Chart.defaults.global, Chart.defaults[chartName], options || {});
				return new ChartType(data,config,this);
			};
		} else{
			warn("Name not provided for this chart, so it hasn't been registered");
		}
		return parent;
	};

	Chart.Element = function(configuration){
		extend(this,configuration);
		this.initialize.apply(this,arguments);
		this.save();
	};
	extend(Chart.Element.prototype,{
		initialize : function(){},
		restore : function(props){
			if (!props){
				extend(this,this._saved);
			} else {
				each(props,function(key){
					this[key] = this._saved[key];
				},this);
			}
			return this;
		},
		save : function(){
			this._saved = clone(this);
			delete this._saved._saved;
			return this;
		},
		update : function(newProps){
			each(newProps,function(value,key){
				this._saved[key] = this[key];
				this[key] = value;
			},this);
			return this;
		},
		transition : function(props,ease){
			each(props,function(value,key){
				this[key] = ((value - this._saved[key]) * ease) + this._saved[key];
			},this);
			return this;
		},
		tooltipPosition : function(){
			return {
				x : this.x,
				y : this.y
			};
		},
		hasValue: function(){
			return isNumber(this.value);
		}
	});

	Chart.Element.extend = inherits;


	Chart.Point = Chart.Element.extend({
		display: true,
		inRange: function(chartX,chartY){
			var hitDetectionRange = this.hitDetectionRadius + this.radius;
			return ((Math.pow(chartX-this.x, 2)+Math.pow(chartY-this.y, 2)) < Math.pow(hitDetectionRange,2));
		},
		draw : function(){
			if (this.display){
				var ctx = this.ctx;
				ctx.beginPath();

				ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);
				ctx.closePath();

				ctx.strokeStyle = this.strokeColor;
				ctx.lineWidth = this.strokeWidth;

				ctx.fillStyle = this.fillColor;

				ctx.fill();
				ctx.stroke();
			}


			//Quick debug for bezier curve splining
			//Highlights control points and the line between them.
			//Handy for dev - stripped in the min version.

			// ctx.save();
			// ctx.fillStyle = "black";
			// ctx.strokeStyle = "black"
			// ctx.beginPath();
			// ctx.arc(this.controlPoints.inner.x,this.controlPoints.inner.y, 2, 0, Math.PI*2);
			// ctx.fill();

			// ctx.beginPath();
			// ctx.arc(this.controlPoints.outer.x,this.controlPoints.outer.y, 2, 0, Math.PI*2);
			// ctx.fill();

			// ctx.moveTo(this.controlPoints.inner.x,this.controlPoints.inner.y);
			// ctx.lineTo(this.x, this.y);
			// ctx.lineTo(this.controlPoints.outer.x,this.controlPoints.outer.y);
			// ctx.stroke();

			// ctx.restore();



		}
	});

	Chart.Arc = Chart.Element.extend({
		inRange : function(chartX,chartY){

			var pointRelativePosition = helpers.getAngleFromPoint(this, {
				x: chartX,
				y: chartY
			});

			//Check if within the range of the open/close angle
			var betweenAngles = (pointRelativePosition.angle >= this.startAngle && pointRelativePosition.angle <= this.endAngle),
				withinRadius = (pointRelativePosition.distance >= this.innerRadius && pointRelativePosition.distance <= this.outerRadius);

			return (betweenAngles && withinRadius);
			//Ensure within the outside of the arc centre, but inside arc outer
		},
		tooltipPosition : function(){
			var centreAngle = this.startAngle + ((this.endAngle - this.startAngle) / 2),
				rangeFromCentre = (this.outerRadius - this.innerRadius) / 2 + this.innerRadius;
			return {
				x : this.x + (Math.cos(centreAngle) * rangeFromCentre),
				y : this.y + (Math.sin(centreAngle) * rangeFromCentre)
			};
		},
		draw : function(){
			var ctx = this.ctx;

			ctx.beginPath();
			ctx.arc(this.x, this.y, this.outerRadius, this.startAngle, this.endAngle);
			ctx.arc(this.x, this.y, this.innerRadius, this.endAngle, this.startAngle, true);

			ctx.closePath();
			ctx.strokeStyle = this.strokeColor;
			ctx.lineWidth = this.strokeWidth;

			ctx.fillStyle = this.fillColor;

			ctx.fill();
			ctx.lineJoin = 'bevel';

			if (this.showStroke){
				ctx.stroke();
			}
		}
	});

	Chart.Rectangle = Chart.Element.extend({
		draw : function(){
			var ctx = this.ctx,
				halfWidth = this.width/2,
				leftX = this.x - halfWidth,
				rightX = this.x + halfWidth,
				top = this.base - (this.base - this.y),
				halfStroke = this.strokeWidth / 2;

			// Canvas doesn't allow us to stroke inside the width so we can
			// adjust the sizes to fit if we're setting a stroke on the line
			if (this.showStroke){
				leftX += halfStroke;
				rightX -= halfStroke;
				top += halfStroke;
			}

			ctx.beginPath();

			ctx.fillStyle = this.fillColor;
			ctx.strokeStyle = this.strokeColor;
			ctx.lineWidth = this.strokeWidth;

			// It'd be nice to keep this class totally generic to any rectangle
			// and simply specify which border to miss out.
			ctx.moveTo(leftX, this.base);
			ctx.lineTo(leftX, top);
			ctx.lineTo(rightX, top);
			ctx.lineTo(rightX, this.base);
			ctx.fill();
			if (this.showStroke){
				ctx.stroke();
			}
		},
		height : function(){
			return this.base - this.y;
		},
		inRange : function(chartX,chartY){
			return (chartX >= this.x - this.width/2 && chartX <= this.x + this.width/2) && (chartY >= this.y && chartY <= this.base);
		}
	});

	Chart.Tooltip = Chart.Element.extend({
		draw : function(){

			var ctx = this.chart.ctx;

			ctx.font = fontString(this.fontSize,this.fontStyle,this.fontFamily);

			this.xAlign = "center";
			this.yAlign = "above";

			//Distance between the actual element.y position and the start of the tooltip caret
			var caretPadding = this.caretPadding = 2;

			var tooltipWidth = ctx.measureText(this.text).width + 2*this.xPadding,
				tooltipRectHeight = this.fontSize + 2*this.yPadding,
				tooltipHeight = tooltipRectHeight + this.caretHeight + caretPadding;

			if (this.x + tooltipWidth/2 >this.chart.width){
				this.xAlign = "left";
			} else if (this.x - tooltipWidth/2 < 0){
				this.xAlign = "right";
			}

			if (this.y - tooltipHeight < 0){
				this.yAlign = "below";
			}


			var tooltipX = this.x - tooltipWidth/2,
				tooltipY = this.y - tooltipHeight;

			ctx.fillStyle = this.fillColor;

			// Custom Tooltips
			if(this.custom){
				this.custom(this);
			}
			else{
				switch(this.yAlign)
				{
				case "above":
					//Draw a caret above the x/y
					ctx.beginPath();
					ctx.moveTo(this.x,this.y - caretPadding);
					ctx.lineTo(this.x + this.caretHeight, this.y - (caretPadding + this.caretHeight));
					ctx.lineTo(this.x - this.caretHeight, this.y - (caretPadding + this.caretHeight));
					ctx.closePath();
					ctx.fill();
					break;
				case "below":
					tooltipY = this.y + caretPadding + this.caretHeight;
					//Draw a caret below the x/y
					ctx.beginPath();
					ctx.moveTo(this.x, this.y + caretPadding);
					ctx.lineTo(this.x + this.caretHeight, this.y + caretPadding + this.caretHeight);
					ctx.lineTo(this.x - this.caretHeight, this.y + caretPadding + this.caretHeight);
					ctx.closePath();
					ctx.fill();
					break;
				}

				switch(this.xAlign)
				{
				case "left":
					tooltipX = this.x - tooltipWidth + (this.cornerRadius + this.caretHeight);
					break;
				case "right":
					tooltipX = this.x - (this.cornerRadius + this.caretHeight);
					break;
				}

				drawRoundedRectangle(ctx,tooltipX,tooltipY,tooltipWidth,tooltipRectHeight,this.cornerRadius);

				ctx.fill();

				ctx.fillStyle = this.textColor;
				ctx.textAlign = "center";
				ctx.textBaseline = "middle";
				ctx.fillText(this.text, tooltipX + tooltipWidth/2, tooltipY + tooltipRectHeight/2);
			}
		}
	});

	Chart.MultiTooltip = Chart.Element.extend({
		initialize : function(){
			this.font = fontString(this.fontSize,this.fontStyle,this.fontFamily);

			this.titleFont = fontString(this.titleFontSize,this.titleFontStyle,this.titleFontFamily);

			this.height = (this.labels.length * this.fontSize) + ((this.labels.length-1) * (this.fontSize/2)) + (this.yPadding*2) + this.titleFontSize *1.5;

			this.ctx.font = this.titleFont;

			var titleWidth = this.ctx.measureText(this.title).width,
				//Label has a legend square as well so account for this.
				labelWidth = longestText(this.ctx,this.font,this.labels) + this.fontSize + 3,
				longestTextWidth = max([labelWidth,titleWidth]);

			this.width = longestTextWidth + (this.xPadding*2);


			var halfHeight = this.height/2;

			//Check to ensure the height will fit on the canvas
			if (this.y - halfHeight < 0 ){
				this.y = halfHeight;
			} else if (this.y + halfHeight > this.chart.height){
				this.y = this.chart.height - halfHeight;
			}

			//Decide whether to align left or right based on position on canvas
			if (this.x > this.chart.width/2){
				this.x -= this.xOffset + this.width;
			} else {
				this.x += this.xOffset;
			}


		},
		getLineHeight : function(index){
			var baseLineHeight = this.y - (this.height/2) + this.yPadding,
				afterTitleIndex = index-1;

			//If the index is zero, we're getting the title
			if (index === 0){
				return baseLineHeight + this.titleFontSize/2;
			} else{
				return baseLineHeight + ((this.fontSize*1.5*afterTitleIndex) + this.fontSize/2) + this.titleFontSize * 1.5;
			}

		},
		draw : function(){
			// Custom Tooltips
			if(this.custom){
				this.custom(this);
			}
			else{
				drawRoundedRectangle(this.ctx,this.x,this.y - this.height/2,this.width,this.height,this.cornerRadius);
				var ctx = this.ctx;
				ctx.fillStyle = this.fillColor;
				ctx.fill();
				ctx.closePath();

				ctx.textAlign = "left";
				ctx.textBaseline = "middle";
				ctx.fillStyle = this.titleTextColor;
				ctx.font = this.titleFont;

				ctx.fillText(this.title,this.x + this.xPadding, this.getLineHeight(0));

				ctx.font = this.font;
				helpers.each(this.labels,function(label,index){
					ctx.fillStyle = this.textColor;
					ctx.fillText(label,this.x + this.xPadding + this.fontSize + 3, this.getLineHeight(index + 1));

					//A bit gnarly, but clearing this rectangle breaks when using explorercanvas (clears whole canvas)
					//ctx.clearRect(this.x + this.xPadding, this.getLineHeight(index + 1) - this.fontSize/2, this.fontSize, this.fontSize);
					//Instead we'll make a white filled block to put the legendColour palette over.

					ctx.fillStyle = this.legendColorBackground;
					ctx.fillRect(this.x + this.xPadding, this.getLineHeight(index + 1) - this.fontSize/2, this.fontSize, this.fontSize);

					ctx.fillStyle = this.legendColors[index].fill;
					ctx.fillRect(this.x + this.xPadding, this.getLineHeight(index + 1) - this.fontSize/2, this.fontSize, this.fontSize);


				},this);
			}
		}
	});

	Chart.Scale = Chart.Element.extend({
		initialize : function(){
			this.fit();
		},
		buildYLabels : function(){
			this.yLabels = [];

			var stepDecimalPlaces = getDecimalPlaces(this.stepValue);

			for (var i=0; i<=this.steps; i++){
				this.yLabels.push(template(this.templateString,{value:(this.min + (i * this.stepValue)).toFixed(stepDecimalPlaces)}));
			}
			this.yLabelWidth = (this.display && this.showLabels) ? longestText(this.ctx,this.font,this.yLabels) : 0;
		},
		addXLabel : function(label){
			if (!this.showXLabels) return;
			this.xLabels.push(label);
			this.valuesCount++;
			this.fit();
		},
		removeXLabel : function(){
			this.xLabels.shift();
			this.valuesCount--;
			this.fit();
		},
		// Fitting loop to rotate x Labels and figure out what fits there, and also calculate how many Y steps to use
		fit: function(){
			// First we need the width of the yLabels, assuming the xLabels aren't rotated

			// To do that we need the base line at the top and base of the chart, assuming there is no x label rotation
			this.startPoint = (this.display) ? this.fontSize : 0;
			this.endPoint = (this.display) ? this.height - (this.fontSize * 1.5) - 5 : this.height; // -5 to pad labels

			// Apply padding settings to the start and end point.
			this.startPoint += this.padding;
			this.endPoint -= this.padding;

			// Cache the starting height, so can determine if we need to recalculate the scale yAxis
			var cachedHeight = this.endPoint - this.startPoint,
				cachedYLabelWidth;

			// Build the current yLabels so we have an idea of what size they'll be to start
			/*
			 *	This sets what is returned from calculateScaleRange as static properties of this class:
			 *
				this.steps;
				this.stepValue;
				this.min;
				this.max;
			 *
			 */
			this.calculateYRange(cachedHeight);

			// With these properties set we can now build the array of yLabels
			// and also the width of the largest yLabel
			this.buildYLabels();

			//if (this.showXLabels) 
			this.calculateXLabelRotation();

			while((cachedHeight > this.endPoint - this.startPoint)){
				cachedHeight = this.endPoint - this.startPoint;
				cachedYLabelWidth = this.yLabelWidth;

				this.calculateYRange(cachedHeight);
				this.buildYLabels();

				// Only go through the xLabel loop again if the yLabel width has changed
				if (cachedYLabelWidth < this.yLabelWidth){
					this.calculateXLabelRotation();
				}
			}

		},
		calculateXLabelRotation : function(){
			//Get the width of each grid by calculating the difference
			//between x offsets between 0 and 1.

			if (!this.showXLabels){
				this.xLabelWidth = 0;
				this.xScalePaddingRight = 10;
				this.xScalePaddingLeft = this.yLabelWidth + 10;
				return;
			}

			this.ctx.font = this.font;

			var firstWidth = this.ctx.measureText(this.xLabels[0]).width,
				lastWidth = this.ctx.measureText(this.xLabels[this.xLabels.length - 1]).width,
				firstRotated,
				lastRotated;


			this.xScalePaddingRight = lastWidth/2 + 3;
			this.xScalePaddingLeft = (firstWidth/2 > this.yLabelWidth + 10) ? firstWidth/2 : this.yLabelWidth + 10;

			this.xLabelRotation = 0;
			if (this.display){
				var originalLabelWidth = longestText(this.ctx,this.font,this.xLabels),
					cosRotation,
					firstRotatedWidth;
				this.xLabelWidth = originalLabelWidth;
				//Allow 3 pixels x2 padding either side for label readability
				var xGridWidth = Math.floor(this.calculateX(1) - this.calculateX(0)) - 6;

				//Max label rotate should be 90 - also act as a loop counter
				while ((this.xLabelWidth > xGridWidth && this.xLabelRotation === 0) || (this.xLabelWidth > xGridWidth && this.xLabelRotation <= 90 && this.xLabelRotation > 0)){
					cosRotation = Math.cos(toRadians(this.xLabelRotation));

					firstRotated = cosRotation * firstWidth;
					lastRotated = cosRotation * lastWidth;

					// We're right aligning the text now.
					if (firstRotated + this.fontSize / 2 > this.yLabelWidth + 8){
						this.xScalePaddingLeft = firstRotated + this.fontSize / 2;
					}
					this.xScalePaddingRight = this.fontSize/2;


					this.xLabelRotation++;
					this.xLabelWidth = cosRotation * originalLabelWidth;

				}
				if (this.xLabelRotation > 0){
					this.endPoint -= Math.sin(toRadians(this.xLabelRotation))*originalLabelWidth + 3;
				}
			}
			else{
				this.xLabelWidth = 0;
				this.xScalePaddingRight = this.padding;
				this.xScalePaddingLeft = this.padding;
			}

		},
		// Needs to be overidden in each Chart type
		// Otherwise we need to pass all the data into the scale class
		calculateYRange: noop,
		drawingArea: function(){
			return this.startPoint - this.endPoint;
		},
		calculateY : function(value){
			var scalingFactor = this.drawingArea() / (this.min - this.max);
			return this.endPoint - (scalingFactor * (value - this.min));
		},
		calculateX : function(index){
			var isRotated = (this.xLabelRotation > 0),
				// innerWidth = (this.offsetGridLines) ? this.width - offsetLeft - this.padding : this.width - (offsetLeft + halfLabelWidth * 2) - this.padding,
				innerWidth = this.width - (this.xScalePaddingLeft + this.xScalePaddingRight),
				valueWidth = innerWidth/Math.max((this.valuesCount - ((this.offsetGridLines) ? 0 : 1)), 1),
				valueOffset = (valueWidth * index) + this.xScalePaddingLeft;

			if (this.offsetGridLines){
				valueOffset += (valueWidth/2);
			}

			return Math.round(valueOffset);
		},
		update : function(newProps){
			helpers.extend(this, newProps);
			this.fit();
		},
		draw : function(){
			var ctx = this.ctx,
				yLabelGap = (this.endPoint - this.startPoint) / this.steps,
				xStart = Math.round(this.xScalePaddingLeft);
			if (this.display){
				ctx.fillStyle = this.textColor;
				ctx.font = this.font;
				each(this.yLabels,function(labelString,index){
					var yLabelCenter = this.endPoint - (yLabelGap * index),
						linePositionY = Math.round(yLabelCenter),
						drawHorizontalLine = this.showHorizontalLines;

					ctx.textAlign = "right";
					ctx.textBaseline = "middle";
					if (this.showLabels){
						ctx.fillText(labelString,xStart - 10,yLabelCenter);
					}

					// This is X axis, so draw it
					if (index === 0 && !drawHorizontalLine){
						drawHorizontalLine = true;
					}

					if (drawHorizontalLine){
						ctx.beginPath();
					}

					if (index > 0){
						// This is a grid line in the centre, so drop that
						ctx.lineWidth = this.gridLineWidth;
						ctx.strokeStyle = this.gridLineColor;
					} else {
						// This is the first line on the scale
						ctx.lineWidth = this.lineWidth;
						ctx.strokeStyle = this.lineColor;
					}

					linePositionY += helpers.aliasPixel(ctx.lineWidth);

					if(drawHorizontalLine){
						ctx.moveTo(xStart, linePositionY);
						ctx.lineTo(this.width, linePositionY);
						ctx.stroke();
						ctx.closePath();
					}

					ctx.lineWidth = this.lineWidth;
					ctx.strokeStyle = this.lineColor;
					ctx.beginPath();
					ctx.moveTo(xStart - 5, linePositionY);
					ctx.lineTo(xStart, linePositionY);
					ctx.stroke();
					ctx.closePath();

				},this);

				if (this.showXLabels)
				each(this.xLabels,function(label,index){
					var xPos = this.calculateX(index) + aliasPixel(this.lineWidth),
						// Check to see if line/bar here and decide where to place the line
						linePos = this.calculateX(index - (this.offsetGridLines ? 0.5 : 0)) + aliasPixel(this.lineWidth),
						isRotated = (this.xLabelRotation > 0),
						drawVerticalLine = this.showVerticalLines;

					// This is Y axis, so draw it
					if (index === 0 && !drawVerticalLine){
						drawVerticalLine = true;
					}

					if (drawVerticalLine){
						ctx.beginPath();
					}

					if (index > 0){
						// This is a grid line in the centre, so drop that
						ctx.lineWidth = this.gridLineWidth;
						ctx.strokeStyle = this.gridLineColor;
					} else {
						// This is the first line on the scale
						ctx.lineWidth = this.lineWidth;
						ctx.strokeStyle = this.lineColor;
					}

					if (drawVerticalLine){
						ctx.moveTo(linePos,this.endPoint);
						ctx.lineTo(linePos,this.startPoint - 3);
						ctx.stroke();
						ctx.closePath();
					}


					ctx.lineWidth = this.lineWidth;
					ctx.strokeStyle = this.lineColor;


					// Small lines at the bottom of the base grid line
					ctx.beginPath();
					ctx.moveTo(linePos,this.endPoint);
					ctx.lineTo(linePos,this.endPoint + 5);
					ctx.stroke();
					ctx.closePath();

					ctx.save();
					ctx.translate(xPos,(isRotated) ? this.endPoint + 12 : this.endPoint + 8);
					ctx.rotate(toRadians(this.xLabelRotation)*-1);
					ctx.font = this.font;
					ctx.textAlign = (isRotated) ? "right" : "center";
					ctx.textBaseline = (isRotated) ? "middle" : "top";
					ctx.fillText(label, 0, 0);
					ctx.restore();
				},this);

			}
		}

	});

	Chart.RadialScale = Chart.Element.extend({
		initialize: function(){
			this.size = min([this.height, this.width]);
			this.drawingArea = (this.display) ? (this.size/2) - (this.fontSize/2 + this.backdropPaddingY) : (this.size/2);
		},
		calculateCenterOffset: function(value){
			// Take into account half font size + the yPadding of the top value
			var scalingFactor = this.drawingArea / (this.max - this.min);

			return (value - this.min) * scalingFactor;
		},
		update : function(){
			if (!this.lineArc){
				this.setScaleSize();
			} else {
				this.drawingArea = (this.display) ? (this.size/2) - (this.fontSize/2 + this.backdropPaddingY) : (this.size/2);
			}
			this.buildYLabels();
		},
		buildYLabels: function(){
			this.yLabels = [];

			var stepDecimalPlaces = getDecimalPlaces(this.stepValue);

			for (var i=0; i<=this.steps; i++){
				this.yLabels.push(template(this.templateString,{value:(this.min + (i * this.stepValue)).toFixed(stepDecimalPlaces)}));
			}
		},
		getCircumference : function(){
			return ((Math.PI*2) / this.valuesCount);
		},
		setScaleSize: function(){
			/*
			 * Right, this is really confusing and there is a lot of maths going on here
			 * The gist of the problem is here: https://gist.github.com/nnnick/696cc9c55f4b0beb8fe9
			 *
			 * Reaction: https://dl.dropboxusercontent.com/u/34601363/toomuchscience.gif
			 *
			 * Solution:
			 *
			 * We assume the radius of the polygon is half the size of the canvas at first
			 * at each index we check if the text overlaps.
			 *
			 * Where it does, we store that angle and that index.
			 *
			 * After finding the largest index and angle we calculate how much we need to remove
			 * from the shape radius to move the point inwards by that x.
			 *
			 * We average the left and right distances to get the maximum shape radius that can fit in the box
			 * along with labels.
			 *
			 * Once we have that, we can find the centre point for the chart, by taking the x text protrusion
			 * on each side, removing that from the size, halving it and adding the left x protrusion width.
			 *
			 * This will mean we have a shape fitted to the canvas, as large as it can be with the labels
			 * and position it in the most space efficient manner
			 *
			 * https://dl.dropboxusercontent.com/u/34601363/yeahscience.gif
			 */


			// Get maximum radius of the polygon. Either half the height (minus the text width) or half the width.
			// Use this to calculate the offset + change. - Make sure L/R protrusion is at least 0 to stop issues with centre points
			var largestPossibleRadius = min([(this.height/2 - this.pointLabelFontSize - 5), this.width/2]),
				pointPosition,
				i,
				textWidth,
				halfTextWidth,
				furthestRight = this.width,
				furthestRightIndex,
				furthestRightAngle,
				furthestLeft = 0,
				furthestLeftIndex,
				furthestLeftAngle,
				xProtrusionLeft,
				xProtrusionRight,
				radiusReductionRight,
				radiusReductionLeft,
				maxWidthRadius;
			this.ctx.font = fontString(this.pointLabelFontSize,this.pointLabelFontStyle,this.pointLabelFontFamily);
			for (i=0;i<this.valuesCount;i++){
				// 5px to space the text slightly out - similar to what we do in the draw function.
				pointPosition = this.getPointPosition(i, largestPossibleRadius);
				textWidth = this.ctx.measureText(template(this.templateString, { value: this.labels[i] })).width + 5;
				if (i === 0 || i === this.valuesCount/2){
					// If we're at index zero, or exactly the middle, we're at exactly the top/bottom
					// of the radar chart, so text will be aligned centrally, so we'll half it and compare
					// w/left and right text sizes
					halfTextWidth = textWidth/2;
					if (pointPosition.x + halfTextWidth > furthestRight) {
						furthestRight = pointPosition.x + halfTextWidth;
						furthestRightIndex = i;
					}
					if (pointPosition.x - halfTextWidth < furthestLeft) {
						furthestLeft = pointPosition.x - halfTextWidth;
						furthestLeftIndex = i;
					}
				}
				else if (i < this.valuesCount/2) {
					// Less than half the values means we'll left align the text
					if (pointPosition.x + textWidth > furthestRight) {
						furthestRight = pointPosition.x + textWidth;
						furthestRightIndex = i;
					}
				}
				else if (i > this.valuesCount/2){
					// More than half the values means we'll right align the text
					if (pointPosition.x - textWidth < furthestLeft) {
						furthestLeft = pointPosition.x - textWidth;
						furthestLeftIndex = i;
					}
				}
			}

			xProtrusionLeft = furthestLeft;

			xProtrusionRight = Math.ceil(furthestRight - this.width);

			furthestRightAngle = this.getIndexAngle(furthestRightIndex);

			furthestLeftAngle = this.getIndexAngle(furthestLeftIndex);

			radiusReductionRight = xProtrusionRight / Math.sin(furthestRightAngle + Math.PI/2);

			radiusReductionLeft = xProtrusionLeft / Math.sin(furthestLeftAngle + Math.PI/2);

			// Ensure we actually need to reduce the size of the chart
			radiusReductionRight = (isNumber(radiusReductionRight)) ? radiusReductionRight : 0;
			radiusReductionLeft = (isNumber(radiusReductionLeft)) ? radiusReductionLeft : 0;

			this.drawingArea = largestPossibleRadius - (radiusReductionLeft + radiusReductionRight)/2;

			//this.drawingArea = min([maxWidthRadius, (this.height - (2 * (this.pointLabelFontSize + 5)))/2])
			this.setCenterPoint(radiusReductionLeft, radiusReductionRight);

		},
		setCenterPoint: function(leftMovement, rightMovement){

			var maxRight = this.width - rightMovement - this.drawingArea,
				maxLeft = leftMovement + this.drawingArea;

			this.xCenter = (maxLeft + maxRight)/2;
			// Always vertically in the centre as the text height doesn't change
			this.yCenter = (this.height/2);
		},

		getIndexAngle : function(index){
			var angleMultiplier = (Math.PI * 2) / this.valuesCount;
			// Start from the top instead of right, so remove a quarter of the circle

			return index * angleMultiplier - (Math.PI/2);
		},
		getPointPosition : function(index, distanceFromCenter){
			var thisAngle = this.getIndexAngle(index);
			return {
				x : (Math.cos(thisAngle) * distanceFromCenter) + this.xCenter,
				y : (Math.sin(thisAngle) * distanceFromCenter) + this.yCenter
			};
		},
		draw: function(){
			if (this.display){
				var ctx = this.ctx;
				each(this.yLabels, function(label, index){
					// Don't draw a centre value
					if (index > 0){
						var yCenterOffset = index * (this.drawingArea/this.steps),
							yHeight = this.yCenter - yCenterOffset,
							pointPosition;

						// Draw circular lines around the scale
						if (this.lineWidth > 0){
							ctx.strokeStyle = this.lineColor;
							ctx.lineWidth = this.lineWidth;

							if(this.lineArc){
								ctx.beginPath();
								ctx.arc(this.xCenter, this.yCenter, yCenterOffset, 0, Math.PI*2);
								ctx.closePath();
								ctx.stroke();
							} else{
								ctx.beginPath();
								for (var i=0;i<this.valuesCount;i++)
								{
									pointPosition = this.getPointPosition(i, this.calculateCenterOffset(this.min + (index * this.stepValue)));
									if (i === 0){
										ctx.moveTo(pointPosition.x, pointPosition.y);
									} else {
										ctx.lineTo(pointPosition.x, pointPosition.y);
									}
								}
								ctx.closePath();
								ctx.stroke();
							}
						}
						if(this.showLabels){
							ctx.font = fontString(this.fontSize,this.fontStyle,this.fontFamily);
							if (this.showLabelBackdrop){
								var labelWidth = ctx.measureText(label).width;
								ctx.fillStyle = this.backdropColor;
								ctx.fillRect(
									this.xCenter - labelWidth/2 - this.backdropPaddingX,
									yHeight - this.fontSize/2 - this.backdropPaddingY,
									labelWidth + this.backdropPaddingX*2,
									this.fontSize + this.backdropPaddingY*2
								);
							}
							ctx.textAlign = 'center';
							ctx.textBaseline = "middle";
							ctx.fillStyle = this.fontColor;
							ctx.fillText(label, this.xCenter, yHeight);
						}
					}
				}, this);

				if (!this.lineArc){
					ctx.lineWidth = this.angleLineWidth;
					ctx.strokeStyle = this.angleLineColor;
					for (var i = this.valuesCount - 1; i >= 0; i--) {
						if (this.angleLineWidth > 0){
							var outerPosition = this.getPointPosition(i, this.calculateCenterOffset(this.max));
							ctx.beginPath();
							ctx.moveTo(this.xCenter, this.yCenter);
							ctx.lineTo(outerPosition.x, outerPosition.y);
							ctx.stroke();
							ctx.closePath();
						}
						// Extra 3px out for some label spacing
						var pointLabelPosition = this.getPointPosition(i, this.calculateCenterOffset(this.max) + 5);
						ctx.font = fontString(this.pointLabelFontSize,this.pointLabelFontStyle,this.pointLabelFontFamily);
						ctx.fillStyle = this.pointLabelFontColor;

						var labelsCount = this.labels.length,
							halfLabelsCount = this.labels.length/2,
							quarterLabelsCount = halfLabelsCount/2,
							upperHalf = (i < quarterLabelsCount || i > labelsCount - quarterLabelsCount),
							exactQuarter = (i === quarterLabelsCount || i === labelsCount - quarterLabelsCount);
						if (i === 0){
							ctx.textAlign = 'center';
						} else if(i === halfLabelsCount){
							ctx.textAlign = 'center';
						} else if (i < halfLabelsCount){
							ctx.textAlign = 'left';
						} else {
							ctx.textAlign = 'right';
						}

						// Set the correct text baseline based on outer positioning
						if (exactQuarter){
							ctx.textBaseline = 'middle';
						} else if (upperHalf){
							ctx.textBaseline = 'bottom';
						} else {
							ctx.textBaseline = 'top';
						}

						ctx.fillText(this.labels[i], pointLabelPosition.x, pointLabelPosition.y);
					}
				}
			}
		}
	});

	// Attach global event to resize each chart instance when the browser resizes
	helpers.addEvent(window, "resize", (function(){
		// Basic debounce of resize function so it doesn't hurt performance when resizing browser.
		var timeout;
		return function(){
			clearTimeout(timeout);
			timeout = setTimeout(function(){
				each(Chart.instances,function(instance){
					// If the responsive flag is set in the chart instance config
					// Cascade the resize event down to the chart.
					if (instance.options.responsive){
						instance.resize(instance.render, true);
					}
				});
			}, 50);
		};
	})());


	if (amd) {
		define(function(){
			return Chart;
		});
	} else if (typeof module === 'object' && module.exports) {
		module.exports = Chart;
	}

	root.Chart = Chart;

	Chart.noConflict = function(){
		root.Chart = previous;
		return Chart;
	};

}).call(this);

(function(){
	"use strict";

	var root = this,
		Chart = root.Chart,
		helpers = Chart.helpers;


	var defaultConfig = {
		//Boolean - Whether the scale should start at zero, or an order of magnitude down from the lowest value
		scaleBeginAtZero : true,

		//Boolean - Whether grid lines are shown across the chart
		scaleShowGridLines : true,

		//String - Colour of the grid lines
		scaleGridLineColor : "rgba(0,0,0,.05)",

		//Number - Width of the grid lines
		scaleGridLineWidth : 1,

		//Boolean - Whether to show horizontal lines (except X axis)
		scaleShowHorizontalLines: true,

		//Boolean - Whether to show vertical lines (except Y axis)
		scaleShowVerticalLines: true,

		//Boolean - If there is a stroke on each bar
		barShowStroke : true,

		//Number - Pixel width of the bar stroke
		barStrokeWidth : 2,

		//Number - Spacing between each of the X value sets
		barValueSpacing : 5,

		//Number - Spacing between data sets within X values
		barDatasetSpacing : 1,

		//String - A legend template
		legendTemplate : "<ul class=\"<%=name.toLowerCase()%>-legend\"><% for (var i=0; i<datasets.length; i++){%><li><span style=\"background-color:<%=datasets[i].fillColor%>\"></span><%if(datasets[i].label){%><%=datasets[i].label%><%}%></li><%}%></ul>"

	};


	Chart.Type.extend({
		name: "Bar",
		defaults : defaultConfig,
		initialize:  function(data){

			//Expose options as a scope variable here so we can access it in the ScaleClass
			var options = this.options;

			this.ScaleClass = Chart.Scale.extend({
				offsetGridLines : true,
				calculateBarX : function(datasetCount, datasetIndex, barIndex){
					//Reusable method for calculating the xPosition of a given bar based on datasetIndex & width of the bar
					var xWidth = this.calculateBaseWidth(),
						xAbsolute = this.calculateX(barIndex) - (xWidth/2),
						barWidth = this.calculateBarWidth(datasetCount);

					return xAbsolute + (barWidth * datasetIndex) + (datasetIndex * options.barDatasetSpacing) + barWidth/2;
				},
				calculateBaseWidth : function(){
					return (this.calculateX(1) - this.calculateX(0)) - (2*options.barValueSpacing);
				},
				calculateBarWidth : function(datasetCount){
					//The padding between datasets is to the right of each bar, providing that there are more than 1 dataset
					var baseWidth = this.calculateBaseWidth() - ((datasetCount - 1) * options.barDatasetSpacing);

					return (baseWidth / datasetCount);
				}
			});

			this.datasets = [];

			//Set up tooltip events on the chart
			if (this.options.showTooltips){
				helpers.bindEvents(this, this.options.tooltipEvents, function(evt){
					var activeBars = (evt.type !== 'mouseout') ? this.getBarsAtEvent(evt) : [];

					this.eachBars(function(bar){
						bar.restore(['fillColor', 'strokeColor']);
					});
					helpers.each(activeBars, function(activeBar){
						activeBar.fillColor = activeBar.highlightFill;
						activeBar.strokeColor = activeBar.highlightStroke;
					});
					this.showTooltip(activeBars);
				});
			}

			//Declare the extension of the default point, to cater for the options passed in to the constructor
			this.BarClass = Chart.Rectangle.extend({
				strokeWidth : this.options.barStrokeWidth,
				showStroke : this.options.barShowStroke,
				ctx : this.chart.ctx
			});

			//Iterate through each of the datasets, and build this into a property of the chart
			helpers.each(data.datasets,function(dataset,datasetIndex){

				var datasetObject = {
					label : dataset.label || null,
					fillColor : dataset.fillColor,
					strokeColor : dataset.strokeColor,
					bars : []
				};

				this.datasets.push(datasetObject);

				helpers.each(dataset.data,function(dataPoint,index){
					//Add a new point for each piece of data, passing any required data to draw.
					datasetObject.bars.push(new this.BarClass({
						value : dataPoint,
						label : data.labels[index],
						datasetLabel: dataset.label,
						strokeColor : dataset.strokeColor,
						fillColor : dataset.fillColor,
						highlightFill : dataset.highlightFill || dataset.fillColor,
						highlightStroke : dataset.highlightStroke || dataset.strokeColor
					}));
				},this);

			},this);

			this.buildScale(data.labels);

			this.BarClass.prototype.base = this.scale.endPoint;

			this.eachBars(function(bar, index, datasetIndex){
				helpers.extend(bar, {
					width : this.scale.calculateBarWidth(this.datasets.length),
					x: this.scale.calculateBarX(this.datasets.length, datasetIndex, index),
					y: this.scale.endPoint
				});
				bar.save();
			}, this);

			this.render();
		},
		update : function(){
			this.scale.update();
			// Reset any highlight colours before updating.
			helpers.each(this.activeElements, function(activeElement){
				activeElement.restore(['fillColor', 'strokeColor']);
			});

			this.eachBars(function(bar){
				bar.save();
			});
			this.render();
		},
		eachBars : function(callback){
			helpers.each(this.datasets,function(dataset, datasetIndex){
				helpers.each(dataset.bars, callback, this, datasetIndex);
			},this);
		},
		getBarsAtEvent : function(e){
			var barsArray = [],
				eventPosition = helpers.getRelativePosition(e),
				datasetIterator = function(dataset){
					barsArray.push(dataset.bars[barIndex]);
				},
				barIndex;

			for (var datasetIndex = 0; datasetIndex < this.datasets.length; datasetIndex++) {
				for (barIndex = 0; barIndex < this.datasets[datasetIndex].bars.length; barIndex++) {
					if (this.datasets[datasetIndex].bars[barIndex].inRange(eventPosition.x,eventPosition.y)){
						helpers.each(this.datasets, datasetIterator);
						return barsArray;
					}
				}
			}

			return barsArray;
		},
		buildScale : function(labels){
			var self = this;

			var dataTotal = function(){
				var values = [];
				self.eachBars(function(bar){
					values.push(bar.value);
				});
				return values;
			};

			var scaleOptions = {
				templateString : this.options.scaleLabel,
				height : this.chart.height,
				width : this.chart.width,
				ctx : this.chart.ctx,
				textColor : this.options.scaleFontColor,
				fontSize : this.options.scaleFontSize,
				fontStyle : this.options.scaleFontStyle,
				fontFamily : this.options.scaleFontFamily,
				valuesCount : labels.length,
				beginAtZero : this.options.scaleBeginAtZero,
				integersOnly : this.options.scaleIntegersOnly,
				calculateYRange: function(currentHeight){
					var updatedRanges = helpers.calculateScaleRange(
						dataTotal(),
						currentHeight,
						this.fontSize,
						this.beginAtZero,
						this.integersOnly
					);
					helpers.extend(this, updatedRanges);
				},
				xLabels : labels,
				font : helpers.fontString(this.options.scaleFontSize, this.options.scaleFontStyle, this.options.scaleFontFamily),
				lineWidth : this.options.scaleLineWidth,
				lineColor : this.options.scaleLineColor,
				showHorizontalLines : this.options.scaleShowHorizontalLines,
				showVerticalLines : this.options.scaleShowVerticalLines,
				gridLineWidth : (this.options.scaleShowGridLines) ? this.options.scaleGridLineWidth : 0,
				gridLineColor : (this.options.scaleShowGridLines) ? this.options.scaleGridLineColor : "rgba(0,0,0,0)",
				padding : (this.options.showScale) ? 0 : (this.options.barShowStroke) ? this.options.barStrokeWidth : 0,
				showLabels : this.options.scaleShowLabels,
				display : this.options.showScale
			};

			if (this.options.scaleOverride){
				helpers.extend(scaleOptions, {
					calculateYRange: helpers.noop,
					steps: this.options.scaleSteps,
					stepValue: this.options.scaleStepWidth,
					min: this.options.scaleStartValue,
					max: this.options.scaleStartValue + (this.options.scaleSteps * this.options.scaleStepWidth)
				});
			}

			this.scale = new this.ScaleClass(scaleOptions);
		},
		addData : function(valuesArray,label){
			//Map the values array for each of the datasets
			helpers.each(valuesArray,function(value,datasetIndex){
				//Add a new point for each piece of data, passing any required data to draw.
				this.datasets[datasetIndex].bars.push(new this.BarClass({
					value : value,
					label : label,
					x: this.scale.calculateBarX(this.datasets.length, datasetIndex, this.scale.valuesCount+1),
					y: this.scale.endPoint,
					width : this.scale.calculateBarWidth(this.datasets.length),
					base : this.scale.endPoint,
					strokeColor : this.datasets[datasetIndex].strokeColor,
					fillColor : this.datasets[datasetIndex].fillColor
				}));
			},this);

			this.scale.addXLabel(label);
			//Then re-render the chart.
			this.update();
		},
		removeData : function(){
			this.scale.removeXLabel();
			//Then re-render the chart.
			helpers.each(this.datasets,function(dataset){
				dataset.bars.shift();
			},this);
			this.update();
		},
		reflow : function(){
			helpers.extend(this.BarClass.prototype,{
				y: this.scale.endPoint,
				base : this.scale.endPoint
			});
			var newScaleProps = helpers.extend({
				height : this.chart.height,
				width : this.chart.width
			});
			this.scale.update(newScaleProps);
		},
		draw : function(ease){
			var easingDecimal = ease || 1;
			this.clear();

			var ctx = this.chart.ctx;

			this.scale.draw(easingDecimal);

			//Draw all the bars for each dataset
			helpers.each(this.datasets,function(dataset,datasetIndex){
				helpers.each(dataset.bars,function(bar,index){
					if (bar.hasValue()){
						bar.base = this.scale.endPoint;
						//Transition then draw
						bar.transition({
							x : this.scale.calculateBarX(this.datasets.length, datasetIndex, index),
							y : this.scale.calculateY(bar.value),
							width : this.scale.calculateBarWidth(this.datasets.length)
						}, easingDecimal).draw();
					}
				},this);

			},this);
		}
	});


}).call(this);

(function(){
	"use strict";

	var root = this,
		Chart = root.Chart,
		//Cache a local reference to Chart.helpers
		helpers = Chart.helpers;

	var defaultConfig = {
		//Boolean - Whether we should show a stroke on each segment
		segmentShowStroke : true,

		//String - The colour of each segment stroke
		segmentStrokeColor : "#fff",

		//Number - The width of each segment stroke
		segmentStrokeWidth : 2,

		//The percentage of the chart that we cut out of the middle.
		percentageInnerCutout : 50,

		//Boolean - Whether we animate the rotation of the Doughnut
		animateRotate : true,

		//Boolean - Whether we animate scaling the Doughnut from the centre
		animateScale : false,

		//String - A legend template
		legendTemplate : "<ul class=\"<%=name.toLowerCase()%>-legend\"><% for (var i=0; i<segments.length; i++){%><li><span style=\"background-color:<%=segments[i].fillColor%>\"></span><%if(segments[i].label){%><%=segments[i].label%><%}%></li><%}%></ul>"

	};


	Chart.Type.extend({
		//Passing in a name registers this chart in the Chart namespace
		name: "Doughnut",
		//Providing a defaults will also register the deafults in the chart namespace
		defaults : defaultConfig,
		//Initialize is fired when the chart is initialized - Data is passed in as a parameter
		//Config is automatically merged by the core of Chart.js, and is available at this.options
		initialize:  function(data){

			//Declare segments as a static property to prevent inheriting across the Chart type prototype
			this.segments = [];
			this.outerRadius = (helpers.min([this.chart.width,this.chart.height]) -	this.options.segmentStrokeWidth/2)/2;

			this.SegmentArc = Chart.Arc.extend({
				ctx : this.chart.ctx,
				x : this.chart.width/2,
				y : this.chart.height/2
			});

			//Set up tooltip events on the chart
			if (this.options.showTooltips){
				helpers.bindEvents(this, this.options.tooltipEvents, function(evt){
					var activeSegments = (evt.type !== 'mouseout') ? this.getSegmentsAtEvent(evt) : [];

					helpers.each(this.segments,function(segment){
						segment.restore(["fillColor"]);
					});
					helpers.each(activeSegments,function(activeSegment){
						activeSegment.fillColor = activeSegment.highlightColor;
					});
					this.showTooltip(activeSegments);
				});
			}
			this.calculateTotal(data);

			helpers.each(data,function(datapoint, index){
				this.addData(datapoint, index, true);
			},this);

			this.render();
		},
		getSegmentsAtEvent : function(e){
			var segmentsArray = [];

			var location = helpers.getRelativePosition(e);

			helpers.each(this.segments,function(segment){
				if (segment.inRange(location.x,location.y)) segmentsArray.push(segment);
			},this);
			return segmentsArray;
		},
		addData : function(segment, atIndex, silent){
			var index = atIndex || this.segments.length;
			this.segments.splice(index, 0, new this.SegmentArc({
				value : segment.value,
				outerRadius : (this.options.animateScale) ? 0 : this.outerRadius,
				innerRadius : (this.options.animateScale) ? 0 : (this.outerRadius/100) * this.options.percentageInnerCutout,
				fillColor : segment.color,
				highlightColor : segment.highlight || segment.color,
				showStroke : this.options.segmentShowStroke,
				strokeWidth : this.options.segmentStrokeWidth,
				strokeColor : this.options.segmentStrokeColor,
				startAngle : Math.PI * 1.5,
				circumference : (this.options.animateRotate) ? 0 : this.calculateCircumference(segment.value),
				label : segment.label
			}));
			if (!silent){
				this.reflow();
				this.update();
			}
		},
		calculateCircumference : function(value){
			return (Math.PI*2)*(Math.abs(value) / this.total);
		},
		calculateTotal : function(data){
			this.total = 0;
			helpers.each(data,function(segment){
				this.total += Math.abs(segment.value);
			},this);
		},
		update : function(){
			this.calculateTotal(this.segments);

			// Reset any highlight colours before updating.
			helpers.each(this.activeElements, function(activeElement){
				activeElement.restore(['fillColor']);
			});

			helpers.each(this.segments,function(segment){
				segment.save();
			});
			this.render();
		},

		removeData: function(atIndex){
			var indexToDelete = (helpers.isNumber(atIndex)) ? atIndex : this.segments.length-1;
			this.segments.splice(indexToDelete, 1);
			this.reflow();
			this.update();
		},

		reflow : function(){
			helpers.extend(this.SegmentArc.prototype,{
				x : this.chart.width/2,
				y : this.chart.height/2
			});
			this.outerRadius = (helpers.min([this.chart.width,this.chart.height]) -	this.options.segmentStrokeWidth/2)/2;
			helpers.each(this.segments, function(segment){
				segment.update({
					outerRadius : this.outerRadius,
					innerRadius : (this.outerRadius/100) * this.options.percentageInnerCutout
				});
			}, this);
		},
		draw : function(easeDecimal){
			var animDecimal = (easeDecimal) ? easeDecimal : 1;
			this.clear();
			helpers.each(this.segments,function(segment,index){
				segment.transition({
					circumference : this.calculateCircumference(segment.value),
					outerRadius : this.outerRadius,
					innerRadius : (this.outerRadius/100) * this.options.percentageInnerCutout
				},animDecimal);

				segment.endAngle = segment.startAngle + segment.circumference;

				segment.draw();
				if (index === 0){
					segment.startAngle = Math.PI * 1.5;
				}
				//Check to see if it's the last segment, if not get the next and update the start angle
				if (index < this.segments.length-1){
					this.segments[index+1].startAngle = segment.endAngle;
				}
			},this);

		}
	});

	Chart.types.Doughnut.extend({
		name : "Pie",
		defaults : helpers.merge(defaultConfig,{percentageInnerCutout : 0})
	});

}).call(this);
(function(){
	"use strict";

	var root = this,
		Chart = root.Chart,
		helpers = Chart.helpers;

	var defaultConfig = {

		///Boolean - Whether grid lines are shown across the chart
		scaleShowGridLines : true,

		//String - Colour of the grid lines
		scaleGridLineColor : "rgba(0,0,0,.05)",

		//Number - Width of the grid lines
		scaleGridLineWidth : 1,

		//Boolean - Whether to show horizontal lines (except X axis)
		scaleShowHorizontalLines: true,

		//Boolean - Whether to show vertical lines (except Y axis)
		scaleShowVerticalLines: true,

		//Boolean - Whether the line is curved between points
		bezierCurve : true,

		//Number - Tension of the bezier curve between points
		bezierCurveTension : 0.4,

		//Boolean - Whether to show a dot for each point
		pointDot : true,

		//Number - Radius of each point dot in pixels
		pointDotRadius : 4,

		//Number - Pixel width of point dot stroke
		pointDotStrokeWidth : 1,

		//Number - amount extra to add to the radius to cater for hit detection outside the drawn point
		pointHitDetectionRadius : 20,

		//Boolean - Whether to show a stroke for datasets
		datasetStroke : true,

		//Number - Pixel width of dataset stroke
		datasetStrokeWidth : 2,

		//Boolean - Whether to fill the dataset with a colour
		datasetFill : true,

		//String - A legend template
		legendTemplate : "<ul class=\"<%=name.toLowerCase()%>-legend\"><% for (var i=0; i<datasets.length; i++){%><li><span style=\"background-color:<%=datasets[i].strokeColor%>\"></span><%if(datasets[i].label){%><%=datasets[i].label%><%}%></li><%}%></ul>"

	};


	Chart.Type.extend({
		name: "Line",
		defaults : defaultConfig,
		initialize:  function(data){
			//Declare the extension of the default point, to cater for the options passed in to the constructor
			this.PointClass = Chart.Point.extend({
				strokeWidth : this.options.pointDotStrokeWidth,
				radius : this.options.pointDotRadius,
				display: this.options.pointDot,
				hitDetectionRadius : this.options.pointHitDetectionRadius,
				ctx : this.chart.ctx,
				inRange : function(mouseX){
					return (Math.pow(mouseX-this.x, 2) < Math.pow(this.radius + this.hitDetectionRadius,2));
				}
			});

			this.datasets = [];

			//Set up tooltip events on the chart
			if (this.options.showTooltips){
				helpers.bindEvents(this, this.options.tooltipEvents, function(evt){
					var activePoints = (evt.type !== 'mouseout') ? this.getPointsAtEvent(evt) : [];
					this.eachPoints(function(point){
						point.restore(['fillColor', 'strokeColor']);
					});
					helpers.each(activePoints, function(activePoint){
						activePoint.fillColor = activePoint.highlightFill;
						activePoint.strokeColor = activePoint.highlightStroke;
					});
					this.showTooltip(activePoints);
				});
			}

			//Iterate through each of the datasets, and build this into a property of the chart
			helpers.each(data.datasets,function(dataset){

				var datasetObject = {
					label : dataset.label || null,
					fillColor : dataset.fillColor,
					strokeColor : dataset.strokeColor,
					pointColor : dataset.pointColor,
					pointStrokeColor : dataset.pointStrokeColor,
					points : []
				};

				this.datasets.push(datasetObject);


				helpers.each(dataset.data,function(dataPoint,index){
					//Add a new point for each piece of data, passing any required data to draw.
					datasetObject.points.push(new this.PointClass({
						value : dataPoint,
						label : data.labels[index],
						datasetLabel: dataset.label,
						strokeColor : dataset.pointStrokeColor,
						fillColor : dataset.pointColor,
						highlightFill : dataset.pointHighlightFill || dataset.pointColor,
						highlightStroke : dataset.pointHighlightStroke || dataset.pointStrokeColor
					}));
				},this);

				this.buildScale(data.labels);


				this.eachPoints(function(point, index){
					helpers.extend(point, {
						x: this.scale.calculateX(index),
						y: this.scale.endPoint
					});
					point.save();
				}, this);

			},this);


			this.render();
		},
		update : function(){
			this.scale.update();
			// Reset any highlight colours before updating.
			helpers.each(this.activeElements, function(activeElement){
				activeElement.restore(['fillColor', 'strokeColor']);
			});
			this.eachPoints(function(point){
				point.save();
			});
			this.render();
		},
		eachPoints : function(callback){
			helpers.each(this.datasets,function(dataset){
				helpers.each(dataset.points,callback,this);
			},this);
		},
		getPointsAtEvent : function(e){
			var pointsArray = [],
				eventPosition = helpers.getRelativePosition(e);
			helpers.each(this.datasets,function(dataset){
				helpers.each(dataset.points,function(point){
					if (point.inRange(eventPosition.x,eventPosition.y)) pointsArray.push(point);
				});
			},this);
			return pointsArray;
		},
		buildScale : function(labels){
			var self = this;

			var dataTotal = function(){
				var values = [];
				self.eachPoints(function(point){
					values.push(point.value);
				});

				return values;
			};

			var scaleOptions = {
				templateString : this.options.scaleLabel,
				height : this.chart.height,
				width : this.chart.width,
				ctx : this.chart.ctx,
				textColor : this.options.scaleFontColor,
				fontSize : this.options.scaleFontSize,
				fontStyle : this.options.scaleFontStyle,
				fontFamily : this.options.scaleFontFamily,
				valuesCount : labels.length,
				beginAtZero : this.options.scaleBeginAtZero,
				integersOnly : this.options.scaleIntegersOnly,
				calculateYRange : function(currentHeight){
					var updatedRanges = helpers.calculateScaleRange(
						dataTotal(),
						currentHeight,
						this.fontSize,
						this.beginAtZero,
						this.integersOnly
					);
					helpers.extend(this, updatedRanges);
				},
				xLabels : labels,
				font : helpers.fontString(this.options.scaleFontSize, this.options.scaleFontStyle, this.options.scaleFontFamily),
				lineWidth : this.options.scaleLineWidth,
				lineColor : this.options.scaleLineColor,
				showHorizontalLines : this.options.scaleShowHorizontalLines,
				showVerticalLines : this.options.scaleShowVerticalLines,
				gridLineWidth : (this.options.scaleShowGridLines) ? this.options.scaleGridLineWidth : 0,
				gridLineColor : (this.options.scaleShowGridLines) ? this.options.scaleGridLineColor : "rgba(0,0,0,0)",
				padding: (this.options.showScale) ? 0 : this.options.pointDotRadius + this.options.pointDotStrokeWidth,
				showLabels : this.options.scaleShowLabels,
				showXLabels : this.options.scaleShowXLabels,
				display : this.options.showScale
			};

			if (this.options.scaleOverride){
				helpers.extend(scaleOptions, {
					calculateYRange: helpers.noop,
					steps: this.options.scaleSteps,
					stepValue: this.options.scaleStepWidth,
					min: this.options.scaleStartValue,
					max: this.options.scaleStartValue + (this.options.scaleSteps * this.options.scaleStepWidth)
				});
			}


			this.scale = new Chart.Scale(scaleOptions);
		},
		addData : function(valuesArray,label){
			//Map the values array for each of the datasets

			helpers.each(valuesArray,function(value,datasetIndex){
				//Add a new point for each piece of data, passing any required data to draw.
				this.datasets[datasetIndex].points.push(new this.PointClass({
					value : value,
					label : label,
					x: this.scale.calculateX(this.scale.valuesCount+1),
					y: this.scale.endPoint,
					strokeColor : this.datasets[datasetIndex].pointStrokeColor,
					fillColor : this.datasets[datasetIndex].pointColor
				}));
			},this);

			this.scale.addXLabel(label);
			//Then re-render the chart.
			this.update();
		},
		removeData : function(){
			this.scale.removeXLabel();
			//Then re-render the chart.
			helpers.each(this.datasets,function(dataset){
				dataset.points.shift();
			},this);
			this.update();
		},
		reflow : function(){
			var newScaleProps = helpers.extend({
				height : this.chart.height,
				width : this.chart.width
			});
			this.scale.update(newScaleProps);
		},
		draw : function(ease){
			var easingDecimal = ease || 1;
			this.clear();

			var ctx = this.chart.ctx;

			// Some helper methods for getting the next/prev points
			var hasValue = function(item){
				return item.value !== null;
			},
			nextPoint = function(point, collection, index){
				return helpers.findNextWhere(collection, hasValue, index) || point;
			},
			previousPoint = function(point, collection, index){
				return helpers.findPreviousWhere(collection, hasValue, index) || point;
			};

			this.scale.draw(easingDecimal);


			helpers.each(this.datasets,function(dataset){
				var pointsWithValues = helpers.where(dataset.points, hasValue);

				//Transition each point first so that the line and point drawing isn't out of sync
				//We can use this extra loop to calculate the control points of this dataset also in this loop

				helpers.each(dataset.points, function(point, index){
					if (point.hasValue()){
						point.transition({
							y : this.scale.calculateY(point.value),
							x : this.scale.calculateX(index)
						}, easingDecimal);
					}
				},this);


				// Control points need to be calculated in a seperate loop, because we need to know the current x/y of the point
				// This would cause issues when there is no animation, because the y of the next point would be 0, so beziers would be skewed
				if (this.options.bezierCurve){
					helpers.each(pointsWithValues, function(point, index){
						var tension = (index > 0 && index < pointsWithValues.length - 1) ? this.options.bezierCurveTension : 0;
						point.controlPoints = helpers.splineCurve(
							previousPoint(point, pointsWithValues, index),
							point,
							nextPoint(point, pointsWithValues, index),
							tension
						);

						// Prevent the bezier going outside of the bounds of the graph

						// Cap puter bezier handles to the upper/lower scale bounds
						if (point.controlPoints.outer.y > this.scale.endPoint){
							point.controlPoints.outer.y = this.scale.endPoint;
						}
						else if (point.controlPoints.outer.y < this.scale.startPoint){
							point.controlPoints.outer.y = this.scale.startPoint;
						}

						// Cap inner bezier handles to the upper/lower scale bounds
						if (point.controlPoints.inner.y > this.scale.endPoint){
							point.controlPoints.inner.y = this.scale.endPoint;
						}
						else if (point.controlPoints.inner.y < this.scale.startPoint){
							point.controlPoints.inner.y = this.scale.startPoint;
						}
					},this);
				}


				//Draw the line between all the points
				ctx.lineWidth = this.options.datasetStrokeWidth;
				ctx.strokeStyle = dataset.strokeColor;
				ctx.beginPath();

				helpers.each(pointsWithValues, function(point, index){
					if (index === 0){
						ctx.moveTo(point.x, point.y);
					}
					else{
						if(this.options.bezierCurve){
							var previous = previousPoint(point, pointsWithValues, index);

							ctx.bezierCurveTo(
								previous.controlPoints.outer.x,
								previous.controlPoints.outer.y,
								point.controlPoints.inner.x,
								point.controlPoints.inner.y,
								point.x,
								point.y
							);
						}
						else{
							ctx.lineTo(point.x,point.y);
						}
					}
				}, this);

				ctx.stroke();

				if (this.options.datasetFill && pointsWithValues.length > 0){
					//Round off the line by going to the base of the chart, back to the start, then fill.
					ctx.lineTo(pointsWithValues[pointsWithValues.length - 1].x, this.scale.endPoint);
					ctx.lineTo(pointsWithValues[0].x, this.scale.endPoint);
					ctx.fillStyle = dataset.fillColor;
					ctx.closePath();
					ctx.fill();
				}

				//Now draw the points over the line
				//A little inefficient double looping, but better than the line
				//lagging behind the point positions
				helpers.each(pointsWithValues,function(point){
					point.draw();
				});
			},this);
		}
	});


}).call(this);

(function(){
	"use strict";

	var root = this,
		Chart = root.Chart,
		//Cache a local reference to Chart.helpers
		helpers = Chart.helpers;

	var defaultConfig = {
		//Boolean - Show a backdrop to the scale label
		scaleShowLabelBackdrop : true,

		//String - The colour of the label backdrop
		scaleBackdropColor : "rgba(255,255,255,0.75)",

		// Boolean - Whether the scale should begin at zero
		scaleBeginAtZero : true,

		//Number - The backdrop padding above & below the label in pixels
		scaleBackdropPaddingY : 2,

		//Number - The backdrop padding to the side of the label in pixels
		scaleBackdropPaddingX : 2,

		//Boolean - Show line for each value in the scale
		scaleShowLine : true,

		//Boolean - Stroke a line around each segment in the chart
		segmentShowStroke : true,

		//String - The colour of the stroke on each segement.
		segmentStrokeColor : "#fff",

		//Number - The width of the stroke value in pixels
		segmentStrokeWidth : 2,

		//Boolean - Whether to animate the rotation of the chart
		animateRotate : true,

		//Boolean - Whether to animate scaling the chart from the centre
		animateScale : false,

		//String - A legend template
		legendTemplate : "<ul class=\"<%=name.toLowerCase()%>-legend\"><% for (var i=0; i<segments.length; i++){%><li><span style=\"background-color:<%=segments[i].fillColor%>\"></span><%if(segments[i].label){%><%=segments[i].label%><%}%></li><%}%></ul>"
	};


	Chart.Type.extend({
		//Passing in a name registers this chart in the Chart namespace
		name: "PolarArea",
		//Providing a defaults will also register the deafults in the chart namespace
		defaults : defaultConfig,
		//Initialize is fired when the chart is initialized - Data is passed in as a parameter
		//Config is automatically merged by the core of Chart.js, and is available at this.options
		initialize:  function(data){
			this.segments = [];
			//Declare segment class as a chart instance specific class, so it can share props for this instance
			this.SegmentArc = Chart.Arc.extend({
				showStroke : this.options.segmentShowStroke,
				strokeWidth : this.options.segmentStrokeWidth,
				strokeColor : this.options.segmentStrokeColor,
				ctx : this.chart.ctx,
				innerRadius : 0,
				x : this.chart.width/2,
				y : this.chart.height/2
			});
			this.scale = new Chart.RadialScale({
				display: this.options.showScale,
				fontStyle: this.options.scaleFontStyle,
				fontSize: this.options.scaleFontSize,
				fontFamily: this.options.scaleFontFamily,
				fontColor: this.options.scaleFontColor,
				showLabels: this.options.scaleShowLabels,
				showLabelBackdrop: this.options.scaleShowLabelBackdrop,
				backdropColor: this.options.scaleBackdropColor,
				backdropPaddingY : this.options.scaleBackdropPaddingY,
				backdropPaddingX: this.options.scaleBackdropPaddingX,
				lineWidth: (this.options.scaleShowLine) ? this.options.scaleLineWidth : 0,
				lineColor: this.options.scaleLineColor,
				lineArc: true,
				width: this.chart.width,
				height: this.chart.height,
				xCenter: this.chart.width/2,
				yCenter: this.chart.height/2,
				ctx : this.chart.ctx,
				templateString: this.options.scaleLabel,
				valuesCount: data.length
			});

			this.updateScaleRange(data);

			this.scale.update();

			helpers.each(data,function(segment,index){
				this.addData(segment,index,true);
			},this);

			//Set up tooltip events on the chart
			if (this.options.showTooltips){
				helpers.bindEvents(this, this.options.tooltipEvents, function(evt){
					var activeSegments = (evt.type !== 'mouseout') ? this.getSegmentsAtEvent(evt) : [];
					helpers.each(this.segments,function(segment){
						segment.restore(["fillColor"]);
					});
					helpers.each(activeSegments,function(activeSegment){
						activeSegment.fillColor = activeSegment.highlightColor;
					});
					this.showTooltip(activeSegments);
				});
			}

			this.render();
		},
		getSegmentsAtEvent : function(e){
			var segmentsArray = [];

			var location = helpers.getRelativePosition(e);

			helpers.each(this.segments,function(segment){
				if (segment.inRange(location.x,location.y)) segmentsArray.push(segment);
			},this);
			return segmentsArray;
		},
		addData : function(segment, atIndex, silent){
			var index = atIndex || this.segments.length;

			this.segments.splice(index, 0, new this.SegmentArc({
				fillColor: segment.color,
				highlightColor: segment.highlight || segment.color,
				label: segment.label,
				value: segment.value,
				outerRadius: (this.options.animateScale) ? 0 : this.scale.calculateCenterOffset(segment.value),
				circumference: (this.options.animateRotate) ? 0 : this.scale.getCircumference(),
				startAngle: Math.PI * 1.5
			}));
			if (!silent){
				this.reflow();
				this.update();
			}
		},
		removeData: function(atIndex){
			var indexToDelete = (helpers.isNumber(atIndex)) ? atIndex : this.segments.length-1;
			this.segments.splice(indexToDelete, 1);
			this.reflow();
			this.update();
		},
		calculateTotal: function(data){
			this.total = 0;
			helpers.each(data,function(segment){
				this.total += segment.value;
			},this);
			this.scale.valuesCount = this.segments.length;
		},
		updateScaleRange: function(datapoints){
			var valuesArray = [];
			helpers.each(datapoints,function(segment){
				valuesArray.push(segment.value);
			});

			var scaleSizes = (this.options.scaleOverride) ?
				{
					steps: this.options.scaleSteps,
					stepValue: this.options.scaleStepWidth,
					min: this.options.scaleStartValue,
					max: this.options.scaleStartValue + (this.options.scaleSteps * this.options.scaleStepWidth)
				} :
				helpers.calculateScaleRange(
					valuesArray,
					helpers.min([this.chart.width, this.chart.height])/2,
					this.options.scaleFontSize,
					this.options.scaleBeginAtZero,
					this.options.scaleIntegersOnly
				);

			helpers.extend(
				this.scale,
				scaleSizes,
				{
					size: helpers.min([this.chart.width, this.chart.height]),
					xCenter: this.chart.width/2,
					yCenter: this.chart.height/2
				}
			);

		},
		update : function(){
			this.calculateTotal(this.segments);

			helpers.each(this.segments,function(segment){
				segment.save();
			});
			
			this.reflow();
			this.render();
		},
		reflow : function(){
			helpers.extend(this.SegmentArc.prototype,{
				x : this.chart.width/2,
				y : this.chart.height/2
			});
			this.updateScaleRange(this.segments);
			this.scale.update();

			helpers.extend(this.scale,{
				xCenter: this.chart.width/2,
				yCenter: this.chart.height/2
			});

			helpers.each(this.segments, function(segment){
				segment.update({
					outerRadius : this.scale.calculateCenterOffset(segment.value)
				});
			}, this);

		},
		draw : function(ease){
			var easingDecimal = ease || 1;
			//Clear & draw the canvas
			this.clear();
			helpers.each(this.segments,function(segment, index){
				segment.transition({
					circumference : this.scale.getCircumference(),
					outerRadius : this.scale.calculateCenterOffset(segment.value)
				},easingDecimal);

				segment.endAngle = segment.startAngle + segment.circumference;

				// If we've removed the first segment we need to set the first one to
				// start at the top.
				if (index === 0){
					segment.startAngle = Math.PI * 1.5;
				}

				//Check to see if it's the last segment, if not get the next and update the start angle
				if (index < this.segments.length - 1){
					this.segments[index+1].startAngle = segment.endAngle;
				}
				segment.draw();
			}, this);
			this.scale.draw();
		}
	});

}).call(this);
(function(){
	"use strict";

	var root = this,
		Chart = root.Chart,
		helpers = Chart.helpers;



	Chart.Type.extend({
		name: "Radar",
		defaults:{
			//Boolean - Whether to show lines for each scale point
			scaleShowLine : true,

			//Boolean - Whether we show the angle lines out of the radar
			angleShowLineOut : true,

			//Boolean - Whether to show labels on the scale
			scaleShowLabels : false,

			// Boolean - Whether the scale should begin at zero
			scaleBeginAtZero : true,

			//String - Colour of the angle line
			angleLineColor : "rgba(0,0,0,.1)",

			//Number - Pixel width of the angle line
			angleLineWidth : 1,

			//String - Point label font declaration
			pointLabelFontFamily : "'Arial'",

			//String - Point label font weight
			pointLabelFontStyle : "normal",

			//Number - Point label font size in pixels
			pointLabelFontSize : 10,

			//String - Point label font colour
			pointLabelFontColor : "#666",

			//Boolean - Whether to show a dot for each point
			pointDot : true,

			//Number - Radius of each point dot in pixels
			pointDotRadius : 3,

			//Number - Pixel width of point dot stroke
			pointDotStrokeWidth : 1,

			//Number - amount extra to add to the radius to cater for hit detection outside the drawn point
			pointHitDetectionRadius : 20,

			//Boolean - Whether to show a stroke for datasets
			datasetStroke : true,

			//Number - Pixel width of dataset stroke
			datasetStrokeWidth : 2,

			//Boolean - Whether to fill the dataset with a colour
			datasetFill : true,

			//String - A legend template
			legendTemplate : "<ul class=\"<%=name.toLowerCase()%>-legend\"><% for (var i=0; i<datasets.length; i++){%><li><span style=\"background-color:<%=datasets[i].strokeColor%>\"></span><%if(datasets[i].label){%><%=datasets[i].label%><%}%></li><%}%></ul>"

		},

		initialize: function(data){
			this.PointClass = Chart.Point.extend({
				strokeWidth : this.options.pointDotStrokeWidth,
				radius : this.options.pointDotRadius,
				display: this.options.pointDot,
				hitDetectionRadius : this.options.pointHitDetectionRadius,
				ctx : this.chart.ctx
			});

			this.datasets = [];

			this.buildScale(data);

			//Set up tooltip events on the chart
			if (this.options.showTooltips){
				helpers.bindEvents(this, this.options.tooltipEvents, function(evt){
					var activePointsCollection = (evt.type !== 'mouseout') ? this.getPointsAtEvent(evt) : [];

					this.eachPoints(function(point){
						point.restore(['fillColor', 'strokeColor']);
					});
					helpers.each(activePointsCollection, function(activePoint){
						activePoint.fillColor = activePoint.highlightFill;
						activePoint.strokeColor = activePoint.highlightStroke;
					});

					this.showTooltip(activePointsCollection);
				});
			}

			//Iterate through each of the datasets, and build this into a property of the chart
			helpers.each(data.datasets,function(dataset){

				var datasetObject = {
					label: dataset.label || null,
					fillColor : dataset.fillColor,
					strokeColor : dataset.strokeColor,
					pointColor : dataset.pointColor,
					pointStrokeColor : dataset.pointStrokeColor,
					points : []
				};

				this.datasets.push(datasetObject);

				helpers.each(dataset.data,function(dataPoint,index){
					//Add a new point for each piece of data, passing any required data to draw.
					var pointPosition;
					if (!this.scale.animation){
						pointPosition = this.scale.getPointPosition(index, this.scale.calculateCenterOffset(dataPoint));
					}
					datasetObject.points.push(new this.PointClass({
						value : dataPoint,
						label : data.labels[index],
						datasetLabel: dataset.label,
						x: pointPosition.x,
						y: pointPosition.y,
						strokeColor : dataset.pointStrokeColor,
						fillColor : dataset.pointColor,
						highlightFill : dataset.pointHighlightFill || dataset.pointColor,
						highlightStroke : dataset.pointHighlightStroke || dataset.pointStrokeColor
					}));
				},this);

			},this);

			this.render();
		},
		eachPoints : function(callback){
			helpers.each(this.datasets,function(dataset){
				helpers.each(dataset.points,callback,this);
			},this);
		},

		getPointsAtEvent : function(evt){
			var mousePosition = helpers.getRelativePosition(evt),
				fromCenter = helpers.getAngleFromPoint({
					x: this.scale.xCenter,
					y: this.scale.yCenter
				}, mousePosition);

			var anglePerIndex = (Math.PI * 2) /this.scale.valuesCount,
				pointIndex = Math.round((fromCenter.angle - Math.PI * 1.5) / anglePerIndex),
				activePointsCollection = [];

			// If we're at the top, make the pointIndex 0 to get the first of the array.
			if (pointIndex >= this.scale.valuesCount || pointIndex < 0){
				pointIndex = 0;
			}

			if (fromCenter.distance <= this.scale.drawingArea){
				helpers.each(this.datasets, function(dataset){
					activePointsCollection.push(dataset.points[pointIndex]);
				});
			}

			return activePointsCollection;
		},

		buildScale : function(data){
			this.scale = new Chart.RadialScale({
				display: this.options.showScale,
				fontStyle: this.options.scaleFontStyle,
				fontSize: this.options.scaleFontSize,
				fontFamily: this.options.scaleFontFamily,
				fontColor: this.options.scaleFontColor,
				showLabels: this.options.scaleShowLabels,
				showLabelBackdrop: this.options.scaleShowLabelBackdrop,
				backdropColor: this.options.scaleBackdropColor,
				backdropPaddingY : this.options.scaleBackdropPaddingY,
				backdropPaddingX: this.options.scaleBackdropPaddingX,
				lineWidth: (this.options.scaleShowLine) ? this.options.scaleLineWidth : 0,
				lineColor: this.options.scaleLineColor,
				angleLineColor : this.options.angleLineColor,
				angleLineWidth : (this.options.angleShowLineOut) ? this.options.angleLineWidth : 0,
				// Point labels at the edge of each line
				pointLabelFontColor : this.options.pointLabelFontColor,
				pointLabelFontSize : this.options.pointLabelFontSize,
				pointLabelFontFamily : this.options.pointLabelFontFamily,
				pointLabelFontStyle : this.options.pointLabelFontStyle,
				height : this.chart.height,
				width: this.chart.width,
				xCenter: this.chart.width/2,
				yCenter: this.chart.height/2,
				ctx : this.chart.ctx,
				templateString: this.options.scaleLabel,
				labels: data.labels,
				valuesCount: data.datasets[0].data.length
			});

			this.scale.setScaleSize();
			this.updateScaleRange(data.datasets);
			this.scale.buildYLabels();
		},
		updateScaleRange: function(datasets){
			var valuesArray = (function(){
				var totalDataArray = [];
				helpers.each(datasets,function(dataset){
					if (dataset.data){
						totalDataArray = totalDataArray.concat(dataset.data);
					}
					else {
						helpers.each(dataset.points, function(point){
							totalDataArray.push(point.value);
						});
					}
				});
				return totalDataArray;
			})();


			var scaleSizes = (this.options.scaleOverride) ?
				{
					steps: this.options.scaleSteps,
					stepValue: this.options.scaleStepWidth,
					min: this.options.scaleStartValue,
					max: this.options.scaleStartValue + (this.options.scaleSteps * this.options.scaleStepWidth)
				} :
				helpers.calculateScaleRange(
					valuesArray,
					helpers.min([this.chart.width, this.chart.height])/2,
					this.options.scaleFontSize,
					this.options.scaleBeginAtZero,
					this.options.scaleIntegersOnly
				);

			helpers.extend(
				this.scale,
				scaleSizes
			);

		},
		addData : function(valuesArray,label){
			//Map the values array for each of the datasets
			this.scale.valuesCount++;
			helpers.each(valuesArray,function(value,datasetIndex){
				var pointPosition = this.scale.getPointPosition(this.scale.valuesCount, this.scale.calculateCenterOffset(value));
				this.datasets[datasetIndex].points.push(new this.PointClass({
					value : value,
					label : label,
					x: pointPosition.x,
					y: pointPosition.y,
					strokeColor : this.datasets[datasetIndex].pointStrokeColor,
					fillColor : this.datasets[datasetIndex].pointColor
				}));
			},this);

			this.scale.labels.push(label);

			this.reflow();

			this.update();
		},
		removeData : function(){
			this.scale.valuesCount--;
			this.scale.labels.shift();
			helpers.each(this.datasets,function(dataset){
				dataset.points.shift();
			},this);
			this.reflow();
			this.update();
		},
		update : function(){
			this.eachPoints(function(point){
				point.save();
			});
			this.reflow();
			this.render();
		},
		reflow: function(){
			helpers.extend(this.scale, {
				width : this.chart.width,
				height: this.chart.height,
				size : helpers.min([this.chart.width, this.chart.height]),
				xCenter: this.chart.width/2,
				yCenter: this.chart.height/2
			});
			this.updateScaleRange(this.datasets);
			this.scale.setScaleSize();
			this.scale.buildYLabels();
		},
		draw : function(ease){
			var easeDecimal = ease || 1,
				ctx = this.chart.ctx;
			this.clear();
			this.scale.draw();

			helpers.each(this.datasets,function(dataset){

				//Transition each point first so that the line and point drawing isn't out of sync
				helpers.each(dataset.points,function(point,index){
					if (point.hasValue()){
						point.transition(this.scale.getPointPosition(index, this.scale.calculateCenterOffset(point.value)), easeDecimal);
					}
				},this);



				//Draw the line between all the points
				ctx.lineWidth = this.options.datasetStrokeWidth;
				ctx.strokeStyle = dataset.strokeColor;
				ctx.beginPath();
				helpers.each(dataset.points,function(point,index){
					if (index === 0){
						ctx.moveTo(point.x,point.y);
					}
					else{
						ctx.lineTo(point.x,point.y);
					}
				},this);
				ctx.closePath();
				ctx.stroke();

				ctx.fillStyle = dataset.fillColor;
				ctx.fill();

				//Now draw the points over the line
				//A little inefficient double looping, but better than the line
				//lagging behind the point positions
				helpers.each(dataset.points,function(point){
					if (point.hasValue()){
						point.draw();
					}
				});

			},this);

		}

	});





}).call(this);/* Zepto v1.1.6 - zepto event ajax form ie - zeptojs.com/license */
var Zepto=function(){function L(t){return null==t?String(t):j[S.call(t)]||"object"}function Z(t){return"function"==L(t)}function _(t){return null!=t&&t==t.window}function $(t){return null!=t&&t.nodeType==t.DOCUMENT_NODE}function D(t){return"object"==L(t)}function M(t){return D(t)&&!_(t)&&Object.getPrototypeOf(t)==Object.prototype}function R(t){return"number"==typeof t.length}function k(t){return s.call(t,function(t){return null!=t})}function z(t){return t.length>0?n.fn.concat.apply([],t):t}function F(t){return t.replace(/::/g,"/").replace(/([A-Z]+)([A-Z][a-z])/g,"$1_$2").replace(/([a-z\d])([A-Z])/g,"$1_$2").replace(/_/g,"-").toLowerCase()}function q(t){return t in f?f[t]:f[t]=new RegExp("(^|\\s)"+t+"(\\s|$)")}function H(t,e){return"number"!=typeof e||c[F(t)]?e:e+"px"}function I(t){var e,n;return u[t]||(e=a.createElement(t),a.body.appendChild(e),n=getComputedStyle(e,"").getPropertyValue("display"),e.parentNode.removeChild(e),"none"==n&&(n="block"),u[t]=n),u[t]}function V(t){return"children"in t?o.call(t.children):n.map(t.childNodes,function(t){return 1==t.nodeType?t:void 0})}function B(n,i,r){for(e in i)r&&(M(i[e])||A(i[e]))?(M(i[e])&&!M(n[e])&&(n[e]={}),A(i[e])&&!A(n[e])&&(n[e]=[]),B(n[e],i[e],r)):i[e]!==t&&(n[e]=i[e])}function U(t,e){return null==e?n(t):n(t).filter(e)}function J(t,e,n,i){return Z(e)?e.call(t,n,i):e}function X(t,e,n){null==n?t.removeAttribute(e):t.setAttribute(e,n)}function W(e,n){var i=e.className||"",r=i&&i.baseVal!==t;return n===t?r?i.baseVal:i:void(r?i.baseVal=n:e.className=n)}function Y(t){try{return t?"true"==t||("false"==t?!1:"null"==t?null:+t+""==t?+t:/^[\[\{]/.test(t)?n.parseJSON(t):t):t}catch(e){return t}}function G(t,e){e(t);for(var n=0,i=t.childNodes.length;i>n;n++)G(t.childNodes[n],e)}var t,e,n,i,C,N,r=[],o=r.slice,s=r.filter,a=window.document,u={},f={},c={"column-count":1,columns:1,"font-weight":1,"line-height":1,opacity:1,"z-index":1,zoom:1},l=/^\s*<(\w+|!)[^>]*>/,h=/^<(\w+)\s*\/?>(?:<\/\1>|)$/,p=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,d=/^(?:body|html)$/i,m=/([A-Z])/g,g=["val","css","html","text","data","width","height","offset"],v=["after","prepend","before","append"],y=a.createElement("table"),x=a.createElement("tr"),b={tr:a.createElement("tbody"),tbody:y,thead:y,tfoot:y,td:x,th:x,"*":a.createElement("div")},w=/complete|loaded|interactive/,E=/^[\w-]*$/,j={},S=j.toString,T={},O=a.createElement("div"),P={tabindex:"tabIndex",readonly:"readOnly","for":"htmlFor","class":"className",maxlength:"maxLength",cellspacing:"cellSpacing",cellpadding:"cellPadding",rowspan:"rowSpan",colspan:"colSpan",usemap:"useMap",frameborder:"frameBorder",contenteditable:"contentEditable"},A=Array.isArray||function(t){return t instanceof Array};return T.matches=function(t,e){if(!e||!t||1!==t.nodeType)return!1;var n=t.webkitMatchesSelector||t.mozMatchesSelector||t.oMatchesSelector||t.matchesSelector;if(n)return n.call(t,e);var i,r=t.parentNode,o=!r;return o&&(r=O).appendChild(t),i=~T.qsa(r,e).indexOf(t),o&&O.removeChild(t),i},C=function(t){return t.replace(/-+(.)?/g,function(t,e){return e?e.toUpperCase():""})},N=function(t){return s.call(t,function(e,n){return t.indexOf(e)==n})},T.fragment=function(e,i,r){var s,u,f;return h.test(e)&&(s=n(a.createElement(RegExp.$1))),s||(e.replace&&(e=e.replace(p,"<$1></$2>")),i===t&&(i=l.test(e)&&RegExp.$1),i in b||(i="*"),f=b[i],f.innerHTML=""+e,s=n.each(o.call(f.childNodes),function(){f.removeChild(this)})),M(r)&&(u=n(s),n.each(r,function(t,e){g.indexOf(t)>-1?u[t](e):u.attr(t,e)})),s},T.Z=function(t,e){return t=t||[],t.__proto__=n.fn,t.selector=e||"",t},T.isZ=function(t){return t instanceof T.Z},T.init=function(e,i){var r;if(!e)return T.Z();if("string"==typeof e)if(e=e.trim(),"<"==e[0]&&l.test(e))r=T.fragment(e,RegExp.$1,i),e=null;else{if(i!==t)return n(i).find(e);r=T.qsa(a,e)}else{if(Z(e))return n(a).ready(e);if(T.isZ(e))return e;if(A(e))r=k(e);else if(D(e))r=[e],e=null;else if(l.test(e))r=T.fragment(e.trim(),RegExp.$1,i),e=null;else{if(i!==t)return n(i).find(e);r=T.qsa(a,e)}}return T.Z(r,e)},n=function(t,e){return T.init(t,e)},n.extend=function(t){var e,n=o.call(arguments,1);return"boolean"==typeof t&&(e=t,t=n.shift()),n.forEach(function(n){B(t,n,e)}),t},T.qsa=function(t,e){var n,i="#"==e[0],r=!i&&"."==e[0],s=i||r?e.slice(1):e,a=E.test(s);return $(t)&&a&&i?(n=t.getElementById(s))?[n]:[]:1!==t.nodeType&&9!==t.nodeType?[]:o.call(a&&!i?r?t.getElementsByClassName(s):t.getElementsByTagName(e):t.querySelectorAll(e))},n.contains=a.documentElement.contains?function(t,e){return t!==e&&t.contains(e)}:function(t,e){for(;e&&(e=e.parentNode);)if(e===t)return!0;return!1},n.type=L,n.isFunction=Z,n.isWindow=_,n.isArray=A,n.isPlainObject=M,n.isEmptyObject=function(t){var e;for(e in t)return!1;return!0},n.inArray=function(t,e,n){return r.indexOf.call(e,t,n)},n.camelCase=C,n.trim=function(t){return null==t?"":String.prototype.trim.call(t)},n.uuid=0,n.support={},n.expr={},n.map=function(t,e){var n,r,o,i=[];if(R(t))for(r=0;r<t.length;r++)n=e(t[r],r),null!=n&&i.push(n);else for(o in t)n=e(t[o],o),null!=n&&i.push(n);return z(i)},n.each=function(t,e){var n,i;if(R(t)){for(n=0;n<t.length;n++)if(e.call(t[n],n,t[n])===!1)return t}else for(i in t)if(e.call(t[i],i,t[i])===!1)return t;return t},n.grep=function(t,e){return s.call(t,e)},window.JSON&&(n.parseJSON=JSON.parse),n.each("Boolean Number String Function Array Date RegExp Object Error".split(" "),function(t,e){j["[object "+e+"]"]=e.toLowerCase()}),n.fn={forEach:r.forEach,reduce:r.reduce,push:r.push,sort:r.sort,indexOf:r.indexOf,concat:r.concat,map:function(t){return n(n.map(this,function(e,n){return t.call(e,n,e)}))},slice:function(){return n(o.apply(this,arguments))},ready:function(t){return w.test(a.readyState)&&a.body?t(n):a.addEventListener("DOMContentLoaded",function(){t(n)},!1),this},get:function(e){return e===t?o.call(this):this[e>=0?e:e+this.length]},toArray:function(){return this.get()},size:function(){return this.length},remove:function(){return this.each(function(){null!=this.parentNode&&this.parentNode.removeChild(this)})},each:function(t){return r.every.call(this,function(e,n){return t.call(e,n,e)!==!1}),this},filter:function(t){return Z(t)?this.not(this.not(t)):n(s.call(this,function(e){return T.matches(e,t)}))},add:function(t,e){return n(N(this.concat(n(t,e))))},is:function(t){return this.length>0&&T.matches(this[0],t)},not:function(e){var i=[];if(Z(e)&&e.call!==t)this.each(function(t){e.call(this,t)||i.push(this)});else{var r="string"==typeof e?this.filter(e):R(e)&&Z(e.item)?o.call(e):n(e);this.forEach(function(t){r.indexOf(t)<0&&i.push(t)})}return n(i)},has:function(t){return this.filter(function(){return D(t)?n.contains(this,t):n(this).find(t).size()})},eq:function(t){return-1===t?this.slice(t):this.slice(t,+t+1)},first:function(){var t=this[0];return t&&!D(t)?t:n(t)},last:function(){var t=this[this.length-1];return t&&!D(t)?t:n(t)},find:function(t){var e,i=this;return e=t?"object"==typeof t?n(t).filter(function(){var t=this;return r.some.call(i,function(e){return n.contains(e,t)})}):1==this.length?n(T.qsa(this[0],t)):this.map(function(){return T.qsa(this,t)}):n()},closest:function(t,e){var i=this[0],r=!1;for("object"==typeof t&&(r=n(t));i&&!(r?r.indexOf(i)>=0:T.matches(i,t));)i=i!==e&&!$(i)&&i.parentNode;return n(i)},parents:function(t){for(var e=[],i=this;i.length>0;)i=n.map(i,function(t){return(t=t.parentNode)&&!$(t)&&e.indexOf(t)<0?(e.push(t),t):void 0});return U(e,t)},parent:function(t){return U(N(this.pluck("parentNode")),t)},children:function(t){return U(this.map(function(){return V(this)}),t)},contents:function(){return this.map(function(){return o.call(this.childNodes)})},siblings:function(t){return U(this.map(function(t,e){return s.call(V(e.parentNode),function(t){return t!==e})}),t)},empty:function(){return this.each(function(){this.innerHTML=""})},pluck:function(t){return n.map(this,function(e){return e[t]})},show:function(){return this.each(function(){"none"==this.style.display&&(this.style.display=""),"none"==getComputedStyle(this,"").getPropertyValue("display")&&(this.style.display=I(this.nodeName))})},replaceWith:function(t){return this.before(t).remove()},wrap:function(t){var e=Z(t);if(this[0]&&!e)var i=n(t).get(0),r=i.parentNode||this.length>1;return this.each(function(o){n(this).wrapAll(e?t.call(this,o):r?i.cloneNode(!0):i)})},wrapAll:function(t){if(this[0]){n(this[0]).before(t=n(t));for(var e;(e=t.children()).length;)t=e.first();n(t).append(this)}return this},wrapInner:function(t){var e=Z(t);return this.each(function(i){var r=n(this),o=r.contents(),s=e?t.call(this,i):t;o.length?o.wrapAll(s):r.append(s)})},unwrap:function(){return this.parent().each(function(){n(this).replaceWith(n(this).children())}),this},clone:function(){return this.map(function(){return this.cloneNode(!0)})},hide:function(){return this.css("display","none")},toggle:function(e){return this.each(function(){var i=n(this);(e===t?"none"==i.css("display"):e)?i.show():i.hide()})},prev:function(t){return n(this.pluck("previousElementSibling")).filter(t||"*")},next:function(t){return n(this.pluck("nextElementSibling")).filter(t||"*")},html:function(t){return 0 in arguments?this.each(function(e){var i=this.innerHTML;n(this).empty().append(J(this,t,e,i))}):0 in this?this[0].innerHTML:null},text:function(t){return 0 in arguments?this.each(function(e){var n=J(this,t,e,this.textContent);this.textContent=null==n?"":""+n}):0 in this?this[0].textContent:null},attr:function(n,i){var r;return"string"!=typeof n||1 in arguments?this.each(function(t){if(1===this.nodeType)if(D(n))for(e in n)X(this,e,n[e]);else X(this,n,J(this,i,t,this.getAttribute(n)))}):this.length&&1===this[0].nodeType?!(r=this[0].getAttribute(n))&&n in this[0]?this[0][n]:r:t},removeAttr:function(t){return this.each(function(){1===this.nodeType&&t.split(" ").forEach(function(t){X(this,t)},this)})},prop:function(t,e){return t=P[t]||t,1 in arguments?this.each(function(n){this[t]=J(this,e,n,this[t])}):this[0]&&this[0][t]},data:function(e,n){var i="data-"+e.replace(m,"-$1").toLowerCase(),r=1 in arguments?this.attr(i,n):this.attr(i);return null!==r?Y(r):t},val:function(t){return 0 in arguments?this.each(function(e){this.value=J(this,t,e,this.value)}):this[0]&&(this[0].multiple?n(this[0]).find("option").filter(function(){return this.selected}).pluck("value"):this[0].value)},offset:function(t){if(t)return this.each(function(e){var i=n(this),r=J(this,t,e,i.offset()),o=i.offsetParent().offset(),s={top:r.top-o.top,left:r.left-o.left};"static"==i.css("position")&&(s.position="relative"),i.css(s)});if(!this.length)return null;var e=this[0].getBoundingClientRect();return{left:e.left+window.pageXOffset,top:e.top+window.pageYOffset,width:Math.round(e.width),height:Math.round(e.height)}},css:function(t,i){if(arguments.length<2){var r,o=this[0];if(!o)return;if(r=getComputedStyle(o,""),"string"==typeof t)return o.style[C(t)]||r.getPropertyValue(t);if(A(t)){var s={};return n.each(t,function(t,e){s[e]=o.style[C(e)]||r.getPropertyValue(e)}),s}}var a="";if("string"==L(t))i||0===i?a=F(t)+":"+H(t,i):this.each(function(){this.style.removeProperty(F(t))});else for(e in t)t[e]||0===t[e]?a+=F(e)+":"+H(e,t[e])+";":this.each(function(){this.style.removeProperty(F(e))});return this.each(function(){this.style.cssText+=";"+a})},index:function(t){return t?this.indexOf(n(t)[0]):this.parent().children().indexOf(this[0])},hasClass:function(t){return t?r.some.call(this,function(t){return this.test(W(t))},q(t)):!1},addClass:function(t){return t?this.each(function(e){if("className"in this){i=[];var r=W(this),o=J(this,t,e,r);o.split(/\s+/g).forEach(function(t){n(this).hasClass(t)||i.push(t)},this),i.length&&W(this,r+(r?" ":"")+i.join(" "))}}):this},removeClass:function(e){return this.each(function(n){if("className"in this){if(e===t)return W(this,"");i=W(this),J(this,e,n,i).split(/\s+/g).forEach(function(t){i=i.replace(q(t)," ")}),W(this,i.trim())}})},toggleClass:function(e,i){return e?this.each(function(r){var o=n(this),s=J(this,e,r,W(this));s.split(/\s+/g).forEach(function(e){(i===t?!o.hasClass(e):i)?o.addClass(e):o.removeClass(e)})}):this},scrollTop:function(e){if(this.length){var n="scrollTop"in this[0];return e===t?n?this[0].scrollTop:this[0].pageYOffset:this.each(n?function(){this.scrollTop=e}:function(){this.scrollTo(this.scrollX,e)})}},scrollLeft:function(e){if(this.length){var n="scrollLeft"in this[0];return e===t?n?this[0].scrollLeft:this[0].pageXOffset:this.each(n?function(){this.scrollLeft=e}:function(){this.scrollTo(e,this.scrollY)})}},position:function(){if(this.length){var t=this[0],e=this.offsetParent(),i=this.offset(),r=d.test(e[0].nodeName)?{top:0,left:0}:e.offset();return i.top-=parseFloat(n(t).css("margin-top"))||0,i.left-=parseFloat(n(t).css("margin-left"))||0,r.top+=parseFloat(n(e[0]).css("border-top-width"))||0,r.left+=parseFloat(n(e[0]).css("border-left-width"))||0,{top:i.top-r.top,left:i.left-r.left}}},offsetParent:function(){return this.map(function(){for(var t=this.offsetParent||a.body;t&&!d.test(t.nodeName)&&"static"==n(t).css("position");)t=t.offsetParent;return t})}},n.fn.detach=n.fn.remove,["width","height"].forEach(function(e){var i=e.replace(/./,function(t){return t[0].toUpperCase()});n.fn[e]=function(r){var o,s=this[0];return r===t?_(s)?s["inner"+i]:$(s)?s.documentElement["scroll"+i]:(o=this.offset())&&o[e]:this.each(function(t){s=n(this),s.css(e,J(this,r,t,s[e]()))})}}),v.forEach(function(t,e){var i=e%2;n.fn[t]=function(){var t,o,r=n.map(arguments,function(e){return t=L(e),"object"==t||"array"==t||null==e?e:T.fragment(e)}),s=this.length>1;return r.length<1?this:this.each(function(t,u){o=i?u:u.parentNode,u=0==e?u.nextSibling:1==e?u.firstChild:2==e?u:null;var f=n.contains(a.documentElement,o);r.forEach(function(t){if(s)t=t.cloneNode(!0);else if(!o)return n(t).remove();o.insertBefore(t,u),f&&G(t,function(t){null==t.nodeName||"SCRIPT"!==t.nodeName.toUpperCase()||t.type&&"text/javascript"!==t.type||t.src||window.eval.call(window,t.innerHTML)})})})},n.fn[i?t+"To":"insert"+(e?"Before":"After")]=function(e){return n(e)[t](this),this}}),T.Z.prototype=n.fn,T.uniq=N,T.deserializeValue=Y,n.zepto=T,n}();window.Zepto=Zepto,void 0===window.$&&(window.$=Zepto),function(t){function l(t){return t._zid||(t._zid=e++)}function h(t,e,n,i){if(e=p(e),e.ns)var r=d(e.ns);return(s[l(t)]||[]).filter(function(t){return!(!t||e.e&&t.e!=e.e||e.ns&&!r.test(t.ns)||n&&l(t.fn)!==l(n)||i&&t.sel!=i)})}function p(t){var e=(""+t).split(".");return{e:e[0],ns:e.slice(1).sort().join(" ")}}function d(t){return new RegExp("(?:^| )"+t.replace(" "," .* ?")+"(?: |$)")}function m(t,e){return t.del&&!u&&t.e in f||!!e}function g(t){return c[t]||u&&f[t]||t}function v(e,i,r,o,a,u,f){var h=l(e),d=s[h]||(s[h]=[]);i.split(/\s/).forEach(function(i){if("ready"==i)return t(document).ready(r);var s=p(i);s.fn=r,s.sel=a,s.e in c&&(r=function(e){var n=e.relatedTarget;return!n||n!==this&&!t.contains(this,n)?s.fn.apply(this,arguments):void 0}),s.del=u;var l=u||r;s.proxy=function(t){if(t=j(t),!t.isImmediatePropagationStopped()){t.data=o;var i=l.apply(e,t._args==n?[t]:[t].concat(t._args));return i===!1&&(t.preventDefault(),t.stopPropagation()),i}},s.i=d.length,d.push(s),"addEventListener"in e&&e.addEventListener(g(s.e),s.proxy,m(s,f))})}function y(t,e,n,i,r){var o=l(t);(e||"").split(/\s/).forEach(function(e){h(t,e,n,i).forEach(function(e){delete s[o][e.i],"removeEventListener"in t&&t.removeEventListener(g(e.e),e.proxy,m(e,r))})})}function j(e,i){return(i||!e.isDefaultPrevented)&&(i||(i=e),t.each(E,function(t,n){var r=i[t];e[t]=function(){return this[n]=x,r&&r.apply(i,arguments)},e[n]=b}),(i.defaultPrevented!==n?i.defaultPrevented:"returnValue"in i?i.returnValue===!1:i.getPreventDefault&&i.getPreventDefault())&&(e.isDefaultPrevented=x)),e}function S(t){var e,i={originalEvent:t};for(e in t)w.test(e)||t[e]===n||(i[e]=t[e]);return j(i,t)}var n,e=1,i=Array.prototype.slice,r=t.isFunction,o=function(t){return"string"==typeof t},s={},a={},u="onfocusin"in window,f={focus:"focusin",blur:"focusout"},c={mouseenter:"mouseover",mouseleave:"mouseout"};a.click=a.mousedown=a.mouseup=a.mousemove="MouseEvents",t.event={add:v,remove:y},t.proxy=function(e,n){var s=2 in arguments&&i.call(arguments,2);if(r(e)){var a=function(){return e.apply(n,s?s.concat(i.call(arguments)):arguments)};return a._zid=l(e),a}if(o(n))return s?(s.unshift(e[n],e),t.proxy.apply(null,s)):t.proxy(e[n],e);throw new TypeError("expected function")},t.fn.bind=function(t,e,n){return this.on(t,e,n)},t.fn.unbind=function(t,e){return this.off(t,e)},t.fn.one=function(t,e,n,i){return this.on(t,e,n,i,1)};var x=function(){return!0},b=function(){return!1},w=/^([A-Z]|returnValue$|layer[XY]$)/,E={preventDefault:"isDefaultPrevented",stopImmediatePropagation:"isImmediatePropagationStopped",stopPropagation:"isPropagationStopped"};t.fn.delegate=function(t,e,n){return this.on(e,t,n)},t.fn.undelegate=function(t,e,n){return this.off(e,t,n)},t.fn.live=function(e,n){return t(document.body).delegate(this.selector,e,n),this},t.fn.die=function(e,n){return t(document.body).undelegate(this.selector,e,n),this},t.fn.on=function(e,s,a,u,f){var c,l,h=this;return e&&!o(e)?(t.each(e,function(t,e){h.on(t,s,a,e,f)}),h):(o(s)||r(u)||u===!1||(u=a,a=s,s=n),(r(a)||a===!1)&&(u=a,a=n),u===!1&&(u=b),h.each(function(n,r){f&&(c=function(t){return y(r,t.type,u),u.apply(this,arguments)}),s&&(l=function(e){var n,o=t(e.target).closest(s,r).get(0);return o&&o!==r?(n=t.extend(S(e),{currentTarget:o,liveFired:r}),(c||u).apply(o,[n].concat(i.call(arguments,1)))):void 0}),v(r,e,u,a,s,l||c)}))},t.fn.off=function(e,i,s){var a=this;return e&&!o(e)?(t.each(e,function(t,e){a.off(t,i,e)}),a):(o(i)||r(s)||s===!1||(s=i,i=n),s===!1&&(s=b),a.each(function(){y(this,e,s,i)}))},t.fn.trigger=function(e,n){return e=o(e)||t.isPlainObject(e)?t.Event(e):j(e),e._args=n,this.each(function(){e.type in f&&"function"==typeof this[e.type]?this[e.type]():"dispatchEvent"in this?this.dispatchEvent(e):t(this).triggerHandler(e,n)})},t.fn.triggerHandler=function(e,n){var i,r;return this.each(function(s,a){i=S(o(e)?t.Event(e):e),i._args=n,i.target=a,t.each(h(a,e.type||e),function(t,e){return r=e.proxy(i),i.isImmediatePropagationStopped()?!1:void 0})}),r},"focusin focusout focus blur load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select keydown keypress keyup error".split(" ").forEach(function(e){t.fn[e]=function(t){return 0 in arguments?this.bind(e,t):this.trigger(e)}}),t.Event=function(t,e){o(t)||(e=t,t=e.type);var n=document.createEvent(a[t]||"Events"),i=!0;if(e)for(var r in e)"bubbles"==r?i=!!e[r]:n[r]=e[r];return n.initEvent(t,i,!0),j(n)}}(Zepto),function(t){function h(e,n,i){var r=t.Event(n);return t(e).trigger(r,i),!r.isDefaultPrevented()}function p(t,e,i,r){return t.global?h(e||n,i,r):void 0}function d(e){e.global&&0===t.active++&&p(e,null,"ajaxStart")}function m(e){e.global&&!--t.active&&p(e,null,"ajaxStop")}function g(t,e){var n=e.context;return e.beforeSend.call(n,t,e)===!1||p(e,n,"ajaxBeforeSend",[t,e])===!1?!1:void p(e,n,"ajaxSend",[t,e])}function v(t,e,n,i){var r=n.context,o="success";n.success.call(r,t,o,e),i&&i.resolveWith(r,[t,o,e]),p(n,r,"ajaxSuccess",[e,n,t]),x(o,e,n)}function y(t,e,n,i,r){var o=i.context;i.error.call(o,n,e,t),r&&r.rejectWith(o,[n,e,t]),p(i,o,"ajaxError",[n,i,t||e]),x(e,n,i)}function x(t,e,n){var i=n.context;n.complete.call(i,e,t),p(n,i,"ajaxComplete",[e,n]),m(n)}function b(){}function w(t){return t&&(t=t.split(";",2)[0]),t&&(t==f?"html":t==u?"json":s.test(t)?"script":a.test(t)&&"xml")||"text"}function E(t,e){return""==e?t:(t+"&"+e).replace(/[&?]{1,2}/,"?")}function j(e){e.processData&&e.data&&"string"!=t.type(e.data)&&(e.data=t.param(e.data,e.traditional)),!e.data||e.type&&"GET"!=e.type.toUpperCase()||(e.url=E(e.url,e.data),e.data=void 0)}function S(e,n,i,r){return t.isFunction(n)&&(r=i,i=n,n=void 0),t.isFunction(i)||(r=i,i=void 0),{url:e,data:n,success:i,dataType:r}}function C(e,n,i,r){var o,s=t.isArray(n),a=t.isPlainObject(n);t.each(n,function(n,u){o=t.type(u),r&&(n=i?r:r+"["+(a||"object"==o||"array"==o?n:"")+"]"),!r&&s?e.add(u.name,u.value):"array"==o||!i&&"object"==o?C(e,u,i,n):e.add(n,u)})}var i,r,e=0,n=window.document,o=/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,s=/^(?:text|application)\/javascript/i,a=/^(?:text|application)\/xml/i,u="application/json",f="text/html",c=/^\s*$/,l=n.createElement("a");l.href=window.location.href,t.active=0,t.ajaxJSONP=function(i,r){if(!("type"in i))return t.ajax(i);var f,h,o=i.jsonpCallback,s=(t.isFunction(o)?o():o)||"jsonp"+ ++e,a=n.createElement("script"),u=window[s],c=function(e){t(a).triggerHandler("error",e||"abort")},l={abort:c};return r&&r.promise(l),t(a).on("load error",function(e,n){clearTimeout(h),t(a).off().remove(),"error"!=e.type&&f?v(f[0],l,i,r):y(null,n||"error",l,i,r),window[s]=u,f&&t.isFunction(u)&&u(f[0]),u=f=void 0}),g(l,i)===!1?(c("abort"),l):(window[s]=function(){f=arguments},a.src=i.url.replace(/\?(.+)=\?/,"?$1="+s),n.head.appendChild(a),i.timeout>0&&(h=setTimeout(function(){c("timeout")},i.timeout)),l)},t.ajaxSettings={type:"GET",beforeSend:b,success:b,error:b,complete:b,context:null,global:!0,xhr:function(){return new window.XMLHttpRequest},accepts:{script:"text/javascript, application/javascript, application/x-javascript",json:u,xml:"application/xml, text/xml",html:f,text:"text/plain"},crossDomain:!1,timeout:0,processData:!0,cache:!0},t.ajax=function(e){var a,o=t.extend({},e||{}),s=t.Deferred&&t.Deferred();for(i in t.ajaxSettings)void 0===o[i]&&(o[i]=t.ajaxSettings[i]);d(o),o.crossDomain||(a=n.createElement("a"),a.href=o.url,a.href=a.href,o.crossDomain=l.protocol+"//"+l.host!=a.protocol+"//"+a.host),o.url||(o.url=window.location.toString()),j(o);var u=o.dataType,f=/\?.+=\?/.test(o.url);if(f&&(u="jsonp"),o.cache!==!1&&(e&&e.cache===!0||"script"!=u&&"jsonp"!=u)||(o.url=E(o.url,"_="+Date.now())),"jsonp"==u)return f||(o.url=E(o.url,o.jsonp?o.jsonp+"=?":o.jsonp===!1?"":"callback=?")),t.ajaxJSONP(o,s);var C,h=o.accepts[u],p={},m=function(t,e){p[t.toLowerCase()]=[t,e]},x=/^([\w-]+:)\/\//.test(o.url)?RegExp.$1:window.location.protocol,S=o.xhr(),T=S.setRequestHeader;if(s&&s.promise(S),o.crossDomain||m("X-Requested-With","XMLHttpRequest"),m("Accept",h||"*/*"),(h=o.mimeType||h)&&(h.indexOf(",")>-1&&(h=h.split(",",2)[0]),S.overrideMimeType&&S.overrideMimeType(h)),(o.contentType||o.contentType!==!1&&o.data&&"GET"!=o.type.toUpperCase())&&m("Content-Type",o.contentType||"application/x-www-form-urlencoded"),o.headers)for(r in o.headers)m(r,o.headers[r]);if(S.setRequestHeader=m,S.onreadystatechange=function(){if(4==S.readyState){S.onreadystatechange=b,clearTimeout(C);var e,n=!1;if(S.status>=200&&S.status<300||304==S.status||0==S.status&&"file:"==x){u=u||w(o.mimeType||S.getResponseHeader("content-type")),e=S.responseText;try{"script"==u?(1,eval)(e):"xml"==u?e=S.responseXML:"json"==u&&(e=c.test(e)?null:t.parseJSON(e))}catch(i){n=i}n?y(n,"parsererror",S,o,s):v(e,S,o,s)}else y(S.statusText||null,S.status?"error":"abort",S,o,s)}},g(S,o)===!1)return S.abort(),y(null,"abort",S,o,s),S;if(o.xhrFields)for(r in o.xhrFields)S[r]=o.xhrFields[r];var N="async"in o?o.async:!0;S.open(o.type,o.url,N,o.username,o.password);for(r in p)T.apply(S,p[r]);return o.timeout>0&&(C=setTimeout(function(){S.onreadystatechange=b,S.abort(),y(null,"timeout",S,o,s)},o.timeout)),S.send(o.data?o.data:null),S},t.get=function(){return t.ajax(S.apply(null,arguments))},t.post=function(){var e=S.apply(null,arguments);return e.type="POST",t.ajax(e)},t.getJSON=function(){var e=S.apply(null,arguments);return e.dataType="json",t.ajax(e)},t.fn.load=function(e,n,i){if(!this.length)return this;var a,r=this,s=e.split(/\s/),u=S(e,n,i),f=u.success;return s.length>1&&(u.url=s[0],a=s[1]),u.success=function(e){r.html(a?t("<div>").html(e.replace(o,"")).find(a):e),f&&f.apply(r,arguments)},t.ajax(u),this};var T=encodeURIComponent;t.param=function(e,n){var i=[];return i.add=function(e,n){t.isFunction(n)&&(n=n()),null==n&&(n=""),this.push(T(e)+"="+T(n))},C(i,e,n),i.join("&").replace(/%20/g,"+")}}(Zepto),function(t){t.fn.serializeArray=function(){var e,n,i=[],r=function(t){return t.forEach?t.forEach(r):void i.push({name:e,value:t})};return this[0]&&t.each(this[0].elements,function(i,o){n=o.type,e=o.name,e&&"fieldset"!=o.nodeName.toLowerCase()&&!o.disabled&&"submit"!=n&&"reset"!=n&&"button"!=n&&"file"!=n&&("radio"!=n&&"checkbox"!=n||o.checked)&&r(t(o).val())}),i},t.fn.serialize=function(){var t=[];return this.serializeArray().forEach(function(e){t.push(encodeURIComponent(e.name)+"="+encodeURIComponent(e.value))}),t.join("&")},t.fn.submit=function(e){if(0 in arguments)this.bind("submit",e);else if(this.length){var n=t.Event("submit");this.eq(0).trigger(n),n.isDefaultPrevented()||this.get(0).submit()}return this}}(Zepto),function(t){"__proto__"in{}||t.extend(t.zepto,{Z:function(e,n){return e=e||[],t.extend(e,t.fn),e.selector=n||"",e.__Z=!0,e},isZ:function(e){return"array"===t.type(e)&&"__Z"in e}});try{getComputedStyle(void 0)}catch(e){var n=getComputedStyle;window.getComputedStyle=function(t){try{return n(t)}catch(e){return null}}}}(Zepto);</script><script>//setTimeout(function (){ location.reload() }, 2e3)</script></head><body style="display:none"><div id="ui_tabbar"><span id="ui_tabbar_btn_menu"></span><a class="ui_tabbar_tab" data-href="#edit">Вождение</a><a class="ui_tabbar_tab" data-href="#view">Данные</a></div><div id="ui_menu"><div id="ui_menu_content"><button id="ui_menu_item_login" class="ui_menu_item" disabled>Войти</button><button id="ui_menu_item_import" class="ui_menu_item" disabled>Импорт данных</button><button id="ui_menu_item_export" class="ui_menu_item" disabled>Экспорт данных</button><button id="ui_menu_item_settings" class="ui_menu_item" disabled>Настройки</button><hr><button id="ui_menu_item_about" class="ui_menu_item">О программе</button></div></div><div id="section_edit" class="div_section"><div id="section_edit_init"><div id="section_edit_init_img"></div><div class="section_footer"><p>Нажмите на эту кнопку, чтобы начать новую смену.</p><button id="section_edit_start">Начать работу</button></div></div><div id="section_edit_work"><h6 id="section_edit_jobs_number"></h6><h6 id="section_edit_current_income"></h6><div id="section_edit_jobs_list_empty"><p>Нажмите на жёлтую кнопку, чтобы зарегистрировать новый заказ.</p></div><div id="section_edit_jobs_list"></div><button id="section_edit_add_job" class="button_circle important" title="Новый клиент"></button><div class="section_footer"><h4 id="section_edit_current_shift"></h4><button id="section_edit_details">Уточнить данные</button><button id="section_edit_finish" class="finish">Завершить работу</button></div></div></div><div id="section_view" class="div_section"><div id="section_view_loading"><p>Загрузка…</p><div class="div_progressbar"><div class="div_progressbar_level" id="section_view_loading_progressbar"></div></div></div><div id="section_view_empty"><p>Сохранённых смен нет.</p></div><div id="section_view_view"><select id="section_view_view_mode"><option value="shifts_list">Таблица</option><option value="stats">Статистика</option><option value="charts">Подробнее</option></select><h6 id="section_view_shifts_number"></h6><div id="section_view_shifts_list"></div><div id="section_view_stats"></div><div id="section_view_charts"><canvas id="section_view_chart_result"></canvas></div></div><!-- <button id="section_view_export">Экспортировать данные</button> --></div><script>function __prototypeExtend(c, 
	p, 
	t){
	t = function (){};
	t.prototype = p.prototype;
	c.prototype = new t();
	c.prototype.constructor = c;
}

function __bindOnce(obj, 
	name){
	if (!obj.hasOwnProperty('__bindTable'))
		obj.__bindTable = {};
	
	if (!obj.__bindTable.hasOwnProperty(name))
		obj.__bindTable[name] = obj[name].bind(obj);
	return obj.__bindTable[name];
}

;

;

;

;

;

;

;

;

;

Number.prototype.postfix = function (){                                            // number.postfix.jsxi:5
	if (Math.round(this) != this)                                                  // number.postfix.jsxi:6
		return arguments[1];                                                       // number.postfix.jsxi:7
	return arguments[this == Number.POSITIVE_INFINITY || this % 10 > 4 && this % 10 <= 9 || this % 10 == 0 || this % 100 > 10 && this % 100 < 20 ? 2 : this % 10 > 1 ? 1 : 0];
};
Number.prototype.toLongString = function (g, r){                                   // number.to_long_string.jsxi:6
	var e = [ '', 'а', 'ов' ],                                                     // number.to_long_string.jsxi:7
		f = [                                                                      // number.to_long_string.jsxi:7
			{ s: 'тысяч', g: 2, e: [ 'а', 'и', '' ] },                             // number.to_long_string.jsxi:7
			'миллион',                                                             // number.to_long_string.jsxi:9
			'миллиард',                                                            // number.to_long_string.jsxi:9
			'триллион',                                                            // number.to_long_string.jsxi:9
			'квадриллион',                                                         // number.to_long_string.jsxi:9
			'квинтиллион',                                                         // number.to_long_string.jsxi:9
			'секстиллион',                                                         // number.to_long_string.jsxi:9
			'септиллион',                                                          // number.to_long_string.jsxi:9
			'октиллион',                                                           // number.to_long_string.jsxi:9
			'нониллион',                                                           // number.to_long_string.jsxi:9
			'дециллион',                                                           // number.to_long_string.jsxi:9
			'андециллион',                                                         // number.to_long_string.jsxi:9
			'дуодециллион',                                                        // number.to_long_string.jsxi:9
			'тредециллион',                                                        // number.to_long_string.jsxi:9
			'кваттордециллион',                                                    // number.to_long_string.jsxi:9
			'квиндециллион',                                                       // number.to_long_string.jsxi:9
			'сексдециллион',                                                       // number.to_long_string.jsxi:9
			'септемдециллион',                                                     // number.to_long_string.jsxi:9
			'октодециллион',                                                       // number.to_long_string.jsxi:9
			'новемдециллион',                                                      // number.to_long_string.jsxi:9
			'вигинтиллион',                                                        // number.to_long_string.jsxi:9
			'анвигинтиллион',                                                      // number.to_long_string.jsxi:9
			'дуовигинтиллион',                                                     // number.to_long_string.jsxi:9
			'тревигинтиллион',                                                     // number.to_long_string.jsxi:9
			'кватторвигинтиллион',                                                 // number.to_long_string.jsxi:9
			'квинвигинтиллион',                                                    // number.to_long_string.jsxi:9
			'сексвигинтиллион',                                                    // number.to_long_string.jsxi:9
			'септемвигинтиллион',                                                  // number.to_long_string.jsxi:9
			'октовигинтиллион',                                                    // number.to_long_string.jsxi:9
			'новемвигинтиллион',                                                   // number.to_long_string.jsxi:9
			'тригинтиллион',                                                       // number.to_long_string.jsxi:9
			'антригинтиллион'
		];
	
	for (var i = f.length; i >= 0; i --){                                          // number.to_long_string.jsxi:11
		var n = Math.pow(1000, i + 1), c = f[i];
		
		if (n <= this){                                                            // number.to_long_string.jsxi:13
			if (!c)                                                                // number.to_long_string.jsxi:14
				return '<ОЧЕНЬ БОЛЬШОЕ ЧИСЛО>';                                    // number.to_long_string.jsxi:14
			
			var big = Math.round(this / n);
			return (big.toLongString(c.g) + ' ' + (c.s || c) + big.postfix((c.e || e)[0], (c.e || e)[1], (c.e || e)[2]) + ' ' + (this % n).toLongString(g, true)).trim();
		}
	}
	
	g = g || 0;                                                                    // number.to_long_string.jsxi:20
	
	var n = this | 0;
	
	var d2 = [                                                                     // number.to_long_string.jsxi:22
			'',                                                                    // number.to_long_string.jsxi:22
			'сто',                                                                 // number.to_long_string.jsxi:22
			'двести',                                                              // number.to_long_string.jsxi:22
			'триста',                                                              // number.to_long_string.jsxi:22
			'четыреста',                                                           // number.to_long_string.jsxi:22
			'пятьсот',                                                             // number.to_long_string.jsxi:22
			'шестьсот',                                                            // number.to_long_string.jsxi:22
			'семьсот',                                                             // number.to_long_string.jsxi:22
			'восемьсот',                                                           // number.to_long_string.jsxi:22
			'девятьсот'
		], 
		d1 = [                                                                     // number.to_long_string.jsxi:23
			'',                                                                    // number.to_long_string.jsxi:23
			'десять',                                                              // number.to_long_string.jsxi:23
			'двадцать',                                                            // number.to_long_string.jsxi:23
			'тридцать',                                                            // number.to_long_string.jsxi:23
			'сорок',                                                               // number.to_long_string.jsxi:23
			'пятьдесят',                                                           // number.to_long_string.jsxi:23
			'шестьдесят',                                                          // number.to_long_string.jsxi:23
			'семьдесят',                                                           // number.to_long_string.jsxi:23
			'восемьдесят',                                                         // number.to_long_string.jsxi:23
			'девяносто'
		], 
		dd = [                                                                     // number.to_long_string.jsxi:24
			'один',                                                                // number.to_long_string.jsxi:24
			'две',                                                                 // number.to_long_string.jsxi:24
			'три',                                                                 // number.to_long_string.jsxi:24
			'четыр',                                                               // number.to_long_string.jsxi:24
			'пят',                                                                 // number.to_long_string.jsxi:24
			'шест',                                                                // number.to_long_string.jsxi:24
			'сем',                                                                 // number.to_long_string.jsxi:24
			'восем',                                                               // number.to_long_string.jsxi:24
			'девят'
		];
	
	d0 = [                                                                         // number.to_long_string.jsxi:25
		'ноль',                                                                    // number.to_long_string.jsxi:25
		[ 'один', 'одно', 'одна' ][g],                                             // number.to_long_string.jsxi:25
		[ 'два', 'два', 'две' ][g],                                                // number.to_long_string.jsxi:25
		'три',                                                                     // number.to_long_string.jsxi:25
		'четыре',                                                                  // number.to_long_string.jsxi:25
		'пять',                                                                    // number.to_long_string.jsxi:25
		'шесть',                                                                   // number.to_long_string.jsxi:25
		'семь',                                                                    // number.to_long_string.jsxi:25
		'восемь',                                                                  // number.to_long_string.jsxi:25
		'девять'
	];
	
	if (n % 100 > 10 && n % 100 < 20)                                              // number.to_long_string.jsxi:26
		return (d2[n / 100 | 0] + ' ' + dd[n % 100 - 11] + 'надцать').trim();      // number.to_long_string.jsxi:26
	return [
		d2[n / 100 | 0],                                                           // number.to_long_string.jsxi:27
		d1[n % 100 / 10 | 0],                                                      // number.to_long_string.jsxi:27
		n == 0 && !r || n % 10 != 0 ? d0[n % 10] : ''
	].filter(function (a){                                                         // number.to_long_string.jsxi:27
		return a.length;                                                           // number.to_long_string.jsxi:27
	}).join(' ');                                                                  // number.to_long_string.jsxi:27
};

function o(n){                                                                     // output.jsxi:3
	if (typeof n !== 'number'){                                                    // output.jsxi:4
		return n;                                                                  // output.jsxi:5
	}
	
	var temp = n.toFixed(1);
	
	if (temp[temp.length - 1] === '0'){                                            // output.jsxi:9
		return + temp;                                                             // output.jsxi:10
	} else {
		return temp.slice(0, - 2) + ',' + temp[temp.length - 1];                   // output.jsxi:12
	}
}

function d(n){                                                                     // output.jsxi:16
	var d = new Date(n).toISOString();
	return d.substr(8, 2) + '.' + d.substr(5, 2) + '.' + d.substr(2, 2) + ' ' + d.substr(11, 5);
}

function t(n){                                                                     // output.jsxi:26
	if (n > 1e12){                                                                 // output.jsxi:27
		var d = new Date(n).toISOString();
		return d.substr(11, 5);                                                    // output.jsxi:29
	} else {
		var t = Math.round(n / 60e3);
		
		var h = Math.floor(t / 60);
		
		var m = t % 60;
		return (h < 10 ? '0' + h : h) + ':' + (m < 10 ? '0' + m : m);              // output.jsxi:34
	}
}

var Mediator = (function (){                                                       // mediator.jsxi:1
	function _splitAndCall(type, fn, arg){                                         // mediator.jsxi:2
		if (Array.isArray(type)){                                                  // mediator.jsxi:3
			for (var i = 0; i < type.length; i ++){                                // mediator.jsxi:4
				fn.call(this, type[i], arg);                                       // mediator.jsxi:5
			}
		} else if (type.indexOf(' ') !== - 1){                                     // mediator.jsxi:7
			type = type.split(' ');                                                // mediator.jsxi:8
			
			for (var i = 0; i < type.length; i ++){                                // mediator.jsxi:9
				fn.call(this, type[i], arg);                                       // mediator.jsxi:10
			}
		} else {
			fn.call(this, type, arg);                                              // mediator.jsxi:13
		}
	}
	
	function _call(type, entry, array){                                            // mediator.jsxi:17
		try {
			return entry.callback.apply(null, array);                              // mediator.jsxi:19
		} catch (e){                                                               // mediator.jsxi:20
			console.warn(e.stack);                                                 // mediator.jsxi:21
			
			if (typeof Mediator.errorHandler === 'function'){                      // mediator.jsxi:23
				try {
					Mediator.errorHandler(e);                                      // mediator.jsxi:25
				} catch (e){} 
			}
		} 
	}
	
	function _on(type, entry){                                                     // mediator.jsxi:31
		console.assert(type && typeof type === 'string' && typeof entry.callback === 'function', 
			'Wrong arg');                                                          // mediator.jsxi:32
		
		var added = false;
		
		this.dispatch('register:' + type,                                          // mediator.jsxi:35
			function (){                                                           // mediator.jsxi:35
				var l = arguments.length, array = new Array(l + 1);
				
				for (var i = 0; i < l; i ++){                                      // mediator.jsxi:37
					array[i] = arguments[i];                                       // mediator.jsxi:38
				}
				
				array[l] = type;                                                   // mediator.jsxi:40
				_call.call(this, type, entry, array);                              // mediator.jsxi:43
				
				if (!entry.one){                                                   // mediator.jsxi:45
					return;
				}
				
				if (added){                                                        // mediator.jsxi:49
					this.off(type, entry.callback);                                // mediator.jsxi:50
				} else {
					this.dispatch('unregister:' + type);                           // mediator.jsxi:52
					entry = null;                                                  // mediator.jsxi:53
				}
			});
		
		if (entry === null){                                                       // mediator.jsxi:57
			return;
		} else {
			added = true;                                                          // mediator.jsxi:60
		}
		
		if (this.listeners.hasOwnProperty(type)){                                  // mediator.jsxi:63
			var array = this.listeners[type];
			
			for (var i = 0; i < array.length; i ++){                               // mediator.jsxi:66
				if (array[i] === null){                                            // mediator.jsxi:67
					array[i] = entry;                                              // mediator.jsxi:68
					return;
				}
			}
			
			this.listeners[type].push(entry);                                      // mediator.jsxi:73
		} else {
			this.listeners[type] = [ entry ];                                      // mediator.jsxi:75
		}
	}
	
	function _offCallback(callback){                                               // mediator.jsxi:79
		for (var type in this.listeners){                                          // mediator.jsxi:80
			var array = this.listeners[type];
			
			for (var i = 0; i < array.length; i ++){                               // mediator.jsxi:83
				if (array[i] !== null && array[i].callback === callback){          // mediator.jsxi:84
					this.dispatch('unregister:' + type);                           // mediator.jsxi:85
					array[i] = null;                                               // mediator.jsxi:86
				}
			}
		}
	}
	
	function _offType(type, callback){                                             // mediator.jsxi:92
		console.assert(typeof callback === 'function', 'Wrong arg');               // mediator.jsxi:93
		
		if (this.listeners.hasOwnProperty(type)){                                  // mediator.jsxi:95
			var array = this.listeners[type];
			
			for (var i = 0; i < array.length; i ++){                               // mediator.jsxi:98
				if (array[i] !== null && array[i].callback === callback){          // mediator.jsxi:99
					this.dispatch('unregister:' + type);                           // mediator.jsxi:100
					array[i] = null;                                               // mediator.jsxi:101
				}
			}
		}
	}
	
	function _dispatch(type, args){                                                // mediator.jsxi:107
		if (this.listeners.hasOwnProperty(type)){                                  // mediator.jsxi:108
			var array = this.listeners[type];
			
			for (var i = 0; i < array.length; i ++){                               // mediator.jsxi:111
				var entry = array[i];
				
				if (entry !== null){                                               // mediator.jsxi:114
					if (entry.one){                                                // mediator.jsxi:115
						this.dispatch('unregister:' + type);                       // mediator.jsxi:116
						array[i] = null;                                           // mediator.jsxi:117
					}
					
					_call.call(this, type, entry, args);                           // mediator.jsxi:121
				}
			}
		}
	}
	
	var Mediator = function (){                                                    // mediator.jsxi:127
		this.listeners = {};                                                       // mediator.jsxi:128
	};
	
	Mediator.prototype.on = function (type, callback){                             // mediator.jsxi:131
		if (typeof type === 'object' && !Array.isArray(type)){                     // mediator.jsxi:132
			for (var k in type){                                                   // mediator.jsxi:133
				this.on(k, type[k]);                                               // mediator.jsxi:134
			}
		} else {
			_splitAndCall.call(this, type, _on, { callback: callback });           // mediator.jsxi:137
		}
		return this;                                                               // mediator.jsxi:139
	};
	Mediator.prototype.one = function (type, callback){                            // mediator.jsxi:142
		if (typeof type === 'object' && !Array.isArray(type)){                     // mediator.jsxi:143
			for (var k in type){                                                   // mediator.jsxi:144
				this.one(k, type[k]);                                              // mediator.jsxi:145
			}
		} else {
			_splitAndCall.call(this, type, _on, { callback: callback, one: true });
		}
		return this;                                                               // mediator.jsxi:150
	};
	Mediator.prototype.off = function (type, callback){                            // mediator.jsxi:153
		if (typeof type === 'function'){                                           // mediator.jsxi:154
			_offCallback.call(this, type);                                         // mediator.jsxi:155
		} else {
			_splitAndCall.call(this, type, _offType, callback);                    // mediator.jsxi:157
		}
		return this;                                                               // mediator.jsxi:159
	};
	Mediator.prototype.dispatch = function (type){                                 // mediator.jsxi:162
		var args = new Array(arguments.length);
		
		for (var i = 1; i < args.length; i ++){                                    // mediator.jsxi:164
			args[i - 1] = arguments[i];                                            // mediator.jsxi:165
		}
		
		args[args.length - 1] = type;                                              // mediator.jsxi:167
		_dispatch.call(this, type, args);                                          // mediator.jsxi:169
		
		for (var index = type.lastIndexOf(':'); index !== - 1; index = type.lastIndexOf(':', index - 1))
			_dispatch.call(this, type.substr(0, index), args);                     // mediator.jsxi:171
		return this;                                                               // mediator.jsxi:173
	};
	Mediator.prototype.extend = function (obj){                                    // mediator.jsxi:176
		if (obj.on === undefined){                                                 // mediator.jsxi:177
			obj.on = this.on.bind(this);                                           // mediator.jsxi:178
		}
		
		if (obj.one === undefined){                                                // mediator.jsxi:181
			obj.one = this.one.bind(this);                                         // mediator.jsxi:182
		}
		
		if (obj.off === undefined){                                                // mediator.jsxi:185
			obj.off = this.off.bind(this);                                         // mediator.jsxi:186
		}
		return obj;                                                                // mediator.jsxi:189
	};
	Mediator.prototype.debug = function (arg){                                     // mediator.jsxi:192
		var result = {};
		
		for (var key in this.listeners){                                           // mediator.jsxi:194
			var filtered = this.listeners[key].filter(function (a){                // mediator.jsxi:195
				return a;                                                          // mediator.jsxi:196
			});
			
			if (typeof arg === 'string' && key !== arg && !key.startsWith(arg + ':')){
				continue;
			}
			
			result[key] = {                                                        // mediator.jsxi:203
				'Listeners': filtered.length,                                      // mediator.jsxi:203
				'First listener at': filtered.length > 0 ? filtered[0].callback.location() : '–', 
				'Allocated': this.listeners[key].length
			};
		}
		
		console.table(result);                                                     // mediator.jsxi:210
		return this;                                                               // mediator.jsxi:211
	};
	Mediator.test = function (){                                                   // mediator.jsxi:214
		var m = new Mediator(), c;
		
		m.on('register',                                                           // mediator.jsxi:217
			function (){                                                           // mediator.jsxi:217
				console.log('REGISTERED', arguments);                              // mediator.jsxi:218
			});
		m.on('unregister',                                                         // mediator.jsxi:220
			function (){                                                           // mediator.jsxi:220
				console.log('UNREGISTERED', arguments);                            // mediator.jsxi:221
			});
		m.on('a',                                                                  // mediator.jsxi:223
			c = function (){                                                       // mediator.jsxi:223
				console.log('A', arguments);                                       // mediator.jsxi:224
			});
		m.on('b',                                                                  // mediator.jsxi:226
			function (){                                                           // mediator.jsxi:226
				console.log('B', arguments);                                       // mediator.jsxi:227
			});
		m.on('a:b',                                                                // mediator.jsxi:229
			function (){                                                           // mediator.jsxi:229
				console.log('A:B', arguments);                                     // mediator.jsxi:230
			});
		m.one('a:b:c',                                                             // mediator.jsxi:232
			function (){                                                           // mediator.jsxi:232
				console.log('A:B:C', arguments);                                   // mediator.jsxi:233
			});
		console.info('a:b, 15');                                                   // mediator.jsxi:235
		m.dispatch('a:b', 15);                                                     // mediator.jsxi:236
		console.info('a:b:c, 16');                                                 // mediator.jsxi:237
		m.dispatch('a:b:c', 16);                                                   // mediator.jsxi:238
		console.info('a:b:c, 17');                                                 // mediator.jsxi:239
		m.dispatch('a:b:c', 17);                                                   // mediator.jsxi:240
		console.info('b, 18');                                                     // mediator.jsxi:241
		m.dispatch('b', 18);                                                       // mediator.jsxi:242
		console.info('a:b, 19');                                                   // mediator.jsxi:243
		m.dispatch('a:b', 19);                                                     // mediator.jsxi:244
		console.info('off');                                                       // mediator.jsxi:245
		m.off(c);                                                                  // mediator.jsxi:246
		console.info('a:b, 20');                                                   // mediator.jsxi:247
		m.dispatch('a:b', 20);                                                     // mediator.jsxi:248
		return m;                                                                  // mediator.jsxi:249
	};
	return Mediator;                                                               // mediator.jsxi:252
})();

/* Class "Dialog" declaration */
function Dialog(title, elements, callback, closeCallback){                         // dialog.jsxi:1
	var __that = this;
	
	this.__Dialog__closeOnEnter = true;
	this.el = document.createElement('div');                                       // dialog.jsxi:10
	this.el.className = 'dialog_wrapper';                                          // dialog.jsxi:11
	this.el.innerHTML = '\t\t\t<div class=\"dialog_vertical_align\"><div class=\"dialog_inner\">\n<div class=\"dialog_header\"><h5>' + title + '</h5></div>\n<div class=\"dialog_content\"></div>\n<div class=\"dialog_buttons\">\n\t<button data-id=\"dialog-ok\">ОК</button>\n</div></div></div>';
	this.$el = $(this.el).click(function (e){                                      // dialog.jsxi:19
		if (e.target.className === 'dialog_vertical_align' && (__that.__Dialog__closeCallback == null || __that.__Dialog__closeCallback !== false && __that.__Dialog__closeCallback(e) !== false)){
			__that.close();
		}
	}).appendTo('body');                                                           // dialog.jsxi:24
	this.header = this.el.querySelector('.dialog_header');                         // dialog.jsxi:26
	this.content = this.el.querySelector('.dialog_content');                       // dialog.jsxi:27
	this.buttons = this.el.querySelector('.dialog_buttons');                       // dialog.jsxi:28
	this.setContent(elements);
	this.__Dialog__callback = callback && callback.bind(this);                     // dialog.jsxi:32
	this.__Dialog__closeCallback = closeCallback && closeCallback.bind(this);      // dialog.jsxi:33
	this.__Dialog__okButton = this.buttons.querySelector('[data-id="dialog-ok"]');
	
	if (this.__Dialog__callback === false){
		this.__Dialog__okButton.style.display = 'none';                            // dialog.jsxi:37
	}
	
	$(this.__Dialog__okButton).click(function (e){                                 // dialog.jsxi:40
		if (!__that.__Dialog__callback || __that.__Dialog__callback(e) !== false){
			__that.close();
		}
	});
	Navigation.sub();                                                              // dialog.jsxi:46
	Navigation.on('subback',                                                       // dialog.jsxi:47
		__bindOnce(this, 
			'close'));
}
Dialog.prototype.setContent = function (elements){                                 // dialog.jsxi:50
	if (!Array.isArray(elements)){                                                 // dialog.jsxi:51
		elements = [ elements ];                                                   // dialog.jsxi:52
	}
	
	var html = '';
	
	for (var __0 = 0; __0 < elements.length; __0 ++){                              // dialog.jsxi:56
		var element = elements[__0];
		
		if (element == null || element === '')                                     // dialog.jsxi:57
			continue;
		
		html += typeof element === 'string' && element[0] !== '<' && element[element.length - 1] !== '>' ? '<p>' + element + '</p>' : element;
	}
	
	this.content.innerHTML = html;                                                 // dialog.jsxi:61
	return this;                                                                   // dialog.jsxi:62
};
Dialog.prototype.closeOnEnter = function (v){                                      // dialog.jsxi:65
	this.__Dialog__closeOnEnter = v;                                               // dialog.jsxi:66
	return this;                                                                   // dialog.jsxi:67
};
Dialog.prototype.onEnd = function (callback){                                      // dialog.jsxi:70
	this.__Dialog__endCallback = callback.bind(this);                              // dialog.jsxi:71
	return this;                                                                   // dialog.jsxi:72
};
Dialog.prototype.setButton = function (a, c){                                      // dialog.jsxi:75
	$(this.__Dialog__okButton).toggle(a != null).text(a);                          // dialog.jsxi:76
	
	if (c != null){                                                                // dialog.jsxi:77
		this.__Dialog__callback = c;                                               // dialog.jsxi:77
	}
	return this;                                                                   // dialog.jsxi:78
};
Dialog.prototype.addButton = function (text, fn){                                  // dialog.jsxi:81
	var __that = this;
	
	fn = fn && fn.bind(this);                                                      // dialog.jsxi:82
	$(document.createElement('button')).text(text).appendTo(this.buttons).click(function (e){
		if (!fn || fn(e) !== false){                                               // dialog.jsxi:84
			__that.close();
		}
	});
	return this;                                                                   // dialog.jsxi:88
};
Dialog.prototype.find = function (a){                                              // dialog.jsxi:91
	return this.$el.find(a);                                                       // dialog.jsxi:92
};
Dialog.prototype.close = function (){                                              // dialog.jsxi:95
	if (this.__Dialog__endCallback)
		this.__Dialog__endCallback();
	
	Navigation.off('subback',                                                      // dialog.jsxi:97
		__bindOnce(this, 
			'close'));
	this.$el.remove();                                                             // dialog.jsxi:98
};

/* Class "Data" declaration */
var Data = (function (){                                                           // data.jsxi:1
	var Data = function (){}, 
		ARCHIVE_PREFIX = 'archive_',                                               // data.jsxi:2
		mediator = new Mediator(),                                                 // data.jsxi:4
		data,                                                                      // data.jsxi:6
		currentShift,                                                              // data.jsxi:6
		statsTimeout;                                                              // data_archive.jsxi:21
	
	Data.archive = null;                                                           // data_archive.jsxi:2
	Data.stats = null;                                                             // data_archive.jsxi:3
	
	function init(){                                                               // data.jsxi:13
		try {
			data = JSON.parse(localStorage.data || null);                          // data.jsxi:14
		} catch (e){} 
		
		if (!data || typeof data !== 'object')                                     // data.jsxi:15
			data = {};                                                             // data.jsxi:15
		
		currentShift = data.currentShift;                                          // data.jsxi:17
		mediator.dispatch('currentShift:load', currentShift);                      // data.jsxi:18
	}
	
	function save(){                                                               // data.jsxi:21
		data.currentShift = currentShift;                                          // data.jsxi:22
		localStorage.data = JSON.stringify(data);                                  // data.jsxi:23
	}
	
	Data.startNewShift = function (){                                              // data.jsxi:26
		currentShift = {                                                           // data.jsxi:27
			timestamp: Date.now(),                                                 // data.jsxi:27
			finished: null,                                                        // data.jsxi:29
			ready: false,                                                          // data.jsxi:31
			details: { distance: null, consumption: null, fuelPrice: null },       // data.jsxi:32
			jobs: []
		};
		save();                                                                    // data.jsxi:41
		mediator.dispatch('currentShift:new', currentShift);                       // data.jsxi:42
	};
	Data.finishShift = function (){                                                // data.jsxi:45
		if (!currentShift.ready)                                                   // data.jsxi:46
			return false;
		
		var shift = currentShift;
		
		shift.finished = Date.now();                                               // data.jsxi:49
		addToArchive(currentShift);                                                // data.jsxi:50
		currentShift = null;                                                       // data.jsxi:52
		save();                                                                    // data.jsxi:53
		mediator.dispatch('currentShift:finish', currentShift);                    // data.jsxi:54
		return shift;                                                              // data.jsxi:56
	};
	Data.getShiftSummary = function (shift){                                       // data.jsxi:59
		var sum = {                                                                // data.jsxi:60
			jobs: 0,                                                               // data.jsxi:60
			jobsHand: 0,                                                           // data.jsxi:62
			jobsOrder: 0,                                                          // data.jsxi:63
			fuelPrice: + (shift.details.distance * shift.details.consumption / 100.0 * shift.details.fuelPrice).toFixed(1), 
			tip: 0.0,                                                              // data.jsxi:67
			lost: 0.0,                                                             // data.jsxi:68
			hand: 0.0,                                                             // data.jsxi:69
			order: 0.0,                                                            // data.jsxi:70
			income: 0.0,                                                           // data.jsxi:72
			result: 0.0,                                                           // data.jsxi:73
			amortization: 0.0
		};
		
		{
			var __2 = shift.jobs;
			
			for (var __1 = 0; __1 < __2.length; __1 ++){
				var j = __2[__1];
				
				sum.jobs ++;                                                       // data.jsxi:78
				sum.tip += j.tip;                                                  // data.jsxi:79
				
				if (j.percent === 1.0){                                            // data.jsxi:81
					sum.jobsHand ++;                                               // data.jsxi:82
					sum.hand += j.sum;                                             // data.jsxi:83
				} else {
					sum.jobsOrder ++;                                              // data.jsxi:85
					sum.order += j.sum * j.percent;                                // data.jsxi:86
					sum.lost = j.sum * (1.0 - j.percent);                          // data.jsxi:87
				}
			}
			
			__2 = undefined;
		}
		
		sum.income = sum.tip + sum.hand + sum.order;                               // data.jsxi:91
		sum.result = sum.income - sum.fuelPrice;                                   // data.jsxi:92
		sum.amortization = sum.result - sum.fuelPrice;                             // data.jsxi:93
		return sum;                                                                // data.jsxi:95
	};
	Data.getCurrentShift = function (){                                            // data.jsxi:98
		return currentShift;                                                       // data.jsxi:99
	};
	Data.addNewJob = function (job){                                               // data.jsxi:102
		if (currentShift == null){                                                 // data.jsxi:103
			return false;
		}
		
		if (Number.isNaN(job.sum = parseFloat(job.sum)) || job.sum < 0.0 || Number.isNaN(job.tip = parseFloat(job.tip)) || Number.isNaN(job.percent = parseFloat(job.percent)) || job.percent < 0.0){
			return false;
		}
		
		job.timestamp = Date.now();                                                // data.jsxi:113
		currentShift.jobs.push(job);                                               // data.jsxi:115
		save();                                                                    // data.jsxi:116
		mediator.dispatch('currentShift.jobs:new', currentShift);                  // data.jsxi:117
	};
	Data.getJobIncome = function (job){                                            // data.jsxi:120
		return job.sum * job.percent + job.tip;                                    // data.jsxi:121
	};
	Data.updateDetails = function (details){                                       // data.jsxi:124
		if (currentShift == null){                                                 // data.jsxi:125
			return false;
		}
		
		if (details.distance != null && (Number.isNaN(details.distance = parseFloat(details.distance)) || details.distance < 0.0) || details.consumption != null && (Number.isNaN(details.consumption = parseFloat(details.consumption)) || details.consumption < 0.0) || details.fuelPrice != null && (Number.isNaN(details.fuelPrice = parseFloat(details.fuelPrice)) || details.fuelPrice < 0.0)){
			return false;
		}
		
		currentShift.details.distance = details.distance;                          // data.jsxi:135
		currentShift.details.consumption = details.consumption;                    // data.jsxi:136
		currentShift.details.fuelPrice = details.fuelPrice;                        // data.jsxi:137
		currentShift.ready = currentShift.details.distance != null && currentShift.details.consumption != null && currentShift.details.fuelPrice != null;
		save();                                                                    // data.jsxi:143
		mediator.dispatch('currentShift.details:update', currentShift);            // data.jsxi:144
	};
	Data.getArchive = function (){                                                 // data_archive.jsxi:5
		return Data.archive;
	};
	Data.getStats = function (){                                                   // data_archive.jsxi:9
		return Data.stats;
	};
	Data.getArchiveById = function (id){                                           // data_archive.jsxi:13
		for (var __3 = 0; __3 < Data.archive.length; __3 ++){
			var a = Data.archive[__3];
			
			if (a.id === id)                                                       // data_archive.jsxi:15
				return a;                                                          // data_archive.jsxi:15
		}
		return null;
	};
	
	function updateStats(entry){                                                   // data_archive.jsxi:22
		if (!Data.stats){
			Data.stats = {
				jobs: 0,                                                           // data_archive.jsxi:25
				jobsHand: 0,                                                       // data_archive.jsxi:26
				jobsOrder: 0,                                                      // data_archive.jsxi:27
				distance: 0.0,                                                     // data_archive.jsxi:28
				fuel: 0.0,                                                         // data_archive.jsxi:29
				time: 0,                                                           // data_archive.jsxi:30
				result: 0.0,                                                       // data_archive.jsxi:32
				fuelPrice: 0.0,                                                    // data_archive.jsxi:33
				tip: 0.0,                                                          // data_archive.jsxi:34
				hand: 0.0,                                                         // data_archive.jsxi:35
				order: 0.0,                                                        // data_archive.jsxi:36
				income: 0.0,                                                       // data_archive.jsxi:37
				lost: 0.0
			};
		}
		
		Data.stats.jobs += entry.summary.jobs;                                     // data_archive.jsxi:42
		Data.stats.jobsHand += entry.summary.jobsHand;                             // data_archive.jsxi:43
		Data.stats.jobsOrder += entry.summary.jobsOrder;                           // data_archive.jsxi:44
		Data.stats.distance += entry.data.details.distance;                        // data_archive.jsxi:45
		Data.stats.fuel += entry.data.details.distance * entry.data.details.consumption / 100;
		Data.stats.time += entry.data.finished - entry.data.timestamp;             // data_archive.jsxi:47
		Data.stats.result += entry.summary.result;                                 // data_archive.jsxi:49
		Data.stats.fuelPrice += entry.summary.fuelPrice;                           // data_archive.jsxi:50
		Data.stats.tip += entry.summary.tip;                                       // data_archive.jsxi:51
		Data.stats.hand += entry.summary.hand;                                     // data_archive.jsxi:52
		Data.stats.order += entry.summary.order;                                   // data_archive.jsxi:53
		Data.stats.income += entry.summary.income;                                 // data_archive.jsxi:54
		Data.stats.lost += entry.summary.lost;                                     // data_archive.jsxi:55
		clearTimeout(statsTimeout);                                                // data_archive.jsxi:57
		statsTimeout = setTimeout(function (arg){                                  // data_archive.jsxi:58
			mediator.dispatch('stats', Data.stats);                                // data_archive.jsxi:59
		}, 
		10);
	}
	
	function addToArchive(shift){                                                  // data_archive.jsxi:63
		var id = ARCHIVE_PREFIX + Date.now();
		
		var json = JSON.stringify(shift);
		
		localStorage[id] = json;                                                   // data_archive.jsxi:67
		
		if (Data.archive != null){
			var summary = Data.getShiftSummary(shift);
			
			var entry = { id: id, json: json, data: shift, summary: summary };     // data_archive.jsxi:70
			
			Data.archive.push(entry);                                              // data_archive.jsxi:71
			updateStats(entry);                                                    // data_archive.jsxi:72
			mediator.dispatch('archive:add', Data.archive);                        // data_archive.jsxi:73
		}
		return summary;                                                            // data_archive.jsxi:76
	}
	
	Data.loadArchive = function (){                                                // data_archive.jsxi:79
		var initMode = Data.archive == null;
		
		if (initMode){                                                             // data_archive.jsxi:81
			Data.archive = [];
		}
		
		var loaded = {}, jsoned = 0;
		
		for (var __4 = 0; __4 < Data.archive.length; __4 ++){
			var a = Data.archive[__4];
			
			loaded[a.id] = true;                                                   // data_archive.jsxi:89
		}
		
		for (var n in localStorage)                                                // data_archive.jsxi:92
			if (localStorage.hasOwnProperty(n)){                                   // data_archive.jsxi:92
				if (n.indexOf(ARCHIVE_PREFIX) !== 0 || loaded.hasOwnProperty(n)){
					continue;
				}
				
				Data.archive.push({ id: n, json: localStorage[n] });               // data_archive.jsxi:97
				jsoned ++;                                                         // data_archive.jsxi:98
			}
		
		if (jsoned > 0){                                                           // data_archive.jsxi:101
			Data.parseJsoned();
		} else if (initMode){                                                      // data_archive.jsxi:103
			mediator.dispatch('archive.loading:finish',                            // data_archive.jsxi:104
				Data.archive.length,                                               // data_archive.jsxi:104
				Data.archive.length);                                              // data_archive.jsxi:104
			mediator.dispatch('archive:load', Data.archive);                       // data_archive.jsxi:105
		}
	};
	Data.parseJsoned = function (){                                                // data_archive.jsxi:109
		mediator.dispatch('archive.loading:start', 0, 
			Data.archive.length);                                                  // data_archive.jsxi:110
		
		var i = 0;
		
		step();                                                                    // data_archive.jsxi:112
		
		function step(){                                                           // data_archive.jsxi:114
			var o = Data.archive[i];
			
			if (o == null){                                                        // data_archive.jsxi:116
				mediator.dispatch('archive.loading:finish',                        // data_archive.jsxi:117
					Data.archive.length,                                           // data_archive.jsxi:117
					Data.archive.length);                                          // data_archive.jsxi:117
				mediator.dispatch('archive:load', Data.archive);                   // data_archive.jsxi:118
				return;
			}
			
			o.data = Data.parseJsonedEntry(o.json);                                // data_archive.jsxi:122
			o.summary = Data.getShiftSummary(o.data);                              // data_archive.jsxi:123
			updateStats(o);                                                        // data_archive.jsxi:124
			mediator.dispatch('archive.loading:step', ++ i, Data.archive.length);
			setTimeout(step);                                                      // data_archive.jsxi:126
		}
	};
	Data.parseJsonedEntry = function (json){                                       // data_archive.jsxi:130
		return JSON.parse(json);                                                   // data_archive.jsxi:131
	};
	Data.guessTip = function (sum){                                                // data_input.jsxi:6
		if (Number.isNaN(+ sum))                                                   // data_input.jsxi:7
			return 0;
		return (100 - + sum % 100) % 100;                                          // data_input.jsxi:8
	};
	(function (){                                                                  // data.jsxi:8
		mediator.extend(Data);                                                     // data.jsxi:9
		$(init);                                                                   // data.jsxi:10
	})();
	return Data;
})();

;

;

/* Class "Navigation" declaration */
var Navigation = (function (){                                                     // navigation.jsxi:1
	var Navigation = function (){};
	
	Navigation.mediator = new Mediator();                                          // navigation.jsxi:2
	Navigation.currentPage = undefined;                                            // navigation.jsxi:3
	Navigation.subMode = undefined;                                                // navigation.jsxi:3
	Navigation.sub = function (){                                                  // navigation.jsxi:5
		location.hash = Navigation.currentPage + '/sub';                           // navigation.jsxi:6
		setTimeout(function (arg){                                                 // navigation.jsxi:7
			return Navigation.subMode = true;
		});
	};
	
	function handler(){                                                            // navigation.jsxi:10
		var page = location.hash.indexOf('#view') === 0 ? 'view' : 'edit';         // navigation.jsxi:11
		
		if (page !== Navigation.currentPage){                                      // navigation.jsxi:12
			Navigation.mediator.dispatch('navigate:' + page, page);                // navigation.jsxi:13
			Navigation.currentPage = page;                                         // navigation.jsxi:14
		} else if (Navigation.subMode){
			Navigation.mediator.dispatch('subback');                               // navigation.jsxi:16
		}
		
		Navigation.subMode = false;
	}
	
	(function (){                                                                  // navigation.jsxi:22
		window.onhashchange = handler;                                             // navigation.jsxi:23
		Navigation.mediator.extend(Navigation);                                    // navigation.jsxi:24
		$(handler);                                                                // navigation.jsxi:25
	})();
	return Navigation;
})();

/* Class "SectionAbstract" declaration */
function SectionAbstract(nodeId){                                                  // app.jsxi:1
	if (this.constructor === SectionAbstract)
		throw new Error('Trying to instantiate abstract class SectionAbstract');
	
	this.__SectionAbstract_id = nodeId;                                            // app.jsxi:6
	this.__node = document.getElementById(nodeId);                                 // app.jsxi:7
	this.__$node = $(this.__node);                                                 // app.jsxi:8
	this.hide();
}
SectionAbstract.prototype.show = function (){                                      // app.jsxi:12
	this.__node.style.display = null;                                              // app.jsxi:13
};
SectionAbstract.prototype.hide = function (){                                      // app.jsxi:16
	this.__node.style.display = 'none';                                            // app.jsxi:17
};
SectionAbstract.prototype.__click = function (action, callback){                   // app.jsxi:20
	document.getElementById(this.__SectionAbstract_id + '_' + action).onclick = callback;
};
SectionAbstract.prototype.__mode = function (mode){                                // app.jsxi:24
	if (mode === this.__currentMode)                                               // app.jsxi:25
		return;
	
	this.__currentMode = mode;                                                     // app.jsxi:27
	
	{
		var __6 = this.__node.children;
		
		for (var __5 = 0; __5 < __6.length; __5 ++){
			var c = __6[__5];
			
			c.style.display = c[c instanceof SectionAbstract ? '__SectionAbstract_id' : 'id'] === this.__SectionAbstract_id + '_' + mode ? null : 'none';
		}
		
		__6 = undefined;
	}
};

/* Class "SectionEdit" declaration */
function SectionEdit(){                                                            // app.jsxi:34
	SectionAbstract.call(this, 
		'section_edit');
	this.__click('start',                                                          // app.jsxi:37
		__bindOnce(this, 
			'startNewShift'));
	this.__click('add_job',                                                        // app.jsxi:38
		__bindOnce(this, 
			'addNewJob'));
	this.__click('details',                                                        // app.jsxi:39
		__bindOnce(this, 
			'updateDetails'));
	this.__click('finish',                                                         // app.jsxi:40
		__bindOnce(this, 
			'finishShift'));
	Data.on('currentShift',                                                        // app.jsxi:42
		__bindOnce(this, 
			'updateCurrentShift'));
	Data.on('currentShift currentShift.jobs',                                      // app.jsxi:43
		__bindOnce(this, 
			'updateCurrentShiftJobs'));
	Data.on('currentShift currentShift.details',                                   // app.jsxi:44
		__bindOnce(this, 
			'updateCurrentShiftDetails'));
}
__prototypeExtend(SectionEdit, 
	SectionAbstract);
SectionEdit.prototype.addNewJob = function (){                                     // app.jsxi:47
	var percents = [ 0.9, 0.8 ];
	
	var tryToGuessTip = true;
	
	var d = new Dialog('Новый клиент',                                             // app.jsxi:51
		[
			'\t\t\t\t\t\t\t\t  \n<p>Процент:\n<select id=\"new_job_percent\">\n\t<option value=\"1.0\">С руки</option>\n\t' + percents.map(function (arg){
				return '<option value="' + arg + '">' + 100 * arg + '%</option>';
			}) + '\n</select></p>\n\n<p>Сумма (₽):\n<input id=\"new_job_sum\" type=\"number\" min=\"0\" step=\"5\" value=\"400\"></input></p>\n\n<p id=\"new_job_tip_section\">Чаевые (₽):\n<input id=\"new_job_tip\" type=\"number\" min=\"0\" step=\"5\" value=\"50\"></input></p>\n'
		], 
		function (arg){                                                            // app.jsxi:63
			var sum = d.find('#new_job_sum').val();
			
			var tip = d.find('#new_job_tip').val();
			
			var percent = d.find('#new_job_percent').val();
			return Data.addNewJob({                                                // app.jsxi:68
				sum: sum,                                                          // app.jsxi:68
				tip: + percent === 1.0 ? 0.0 : tip,                                // app.jsxi:69
				percent: percent
			});
		});
	
	d.find('#new_job_sum').val(localStorage.prevSum || 400).on('change',           // app.jsxi:73
		function (arg){                                                            // app.jsxi:73
			var val = parseFloat(this.value);
			
			if (!this.value || Number.isNaN(val) || val < 0)                       // app.jsxi:75
				return;
			
			localStorage.prevSum = + val;                                          // app.jsxi:77
			
			if (tryToGuessTip){                                                    // app.jsxi:78
				d.find('#new_job_tip').val(Data.guessTip(val));                    // app.jsxi:79
			}
		}).on('keydown',                                                           // app.jsxi:81
		function (arg){                                                            // app.jsxi:81
			if (arg.keyCode === 13){                                               // app.jsxi:82
				d.find('#new_job_tip')[0].select();                                // app.jsxi:83
			}
		})[0].select();                                                            // app.jsxi:85
	d.find('#new_job_tip').val(Data.guessTip(localStorage.prevSum || 400)).on('change', 
		function (arg){                                                            // app.jsxi:87
			tryToGuessTip = false;                                                 // app.jsxi:88
			localStorage.prevTip = this.value;                                     // app.jsxi:89
		}).on('keydown',                                                           // app.jsxi:90
		function (arg){                                                            // app.jsxi:90
			if (arg.keyCode === 13){                                               // app.jsxi:91
				d.find('#new_job_percent')[0].focus();                             // app.jsxi:92
			}
		});
	d.find('#new_job_percent').val(localStorage.prevPercent || percents[0]).on('change', 
		function (arg){                                                            // app.jsxi:96
			if (+ this.value < 1.0){                                               // app.jsxi:97
				localStorage.prevPercent = this.value;                             // app.jsxi:98
			}
			
			d.find('#new_job_tip_section').toggle(+ this.value < 1.0);             // app.jsxi:101
		});
};
SectionEdit.prototype.startNewShift = function (){                                 // app.jsxi:105
	Data.startNewShift();                                                          // app.jsxi:106
	this.show();
};
SectionEdit.prototype.updateDetails = function (){                                 // app.jsxi:110
	var currentShift = Data.getCurrentShift();
	
	if (currentShift == null)                                                      // app.jsxi:112
		return;
	
	var d = new Dialog('Детали смены',                                             // app.jsxi:114
		[
			'Общий пробег (км):',                                                  // app.jsxi:115
			'<input id="details_distance" type="number" min="0" step="1"></input>', 
			'Расход топлива (л/100 км):',                                          // app.jsxi:118
			'<input id="details_consumption" type="number" min="0" step="0.1"></input>', 
			'Цена топлива (₽/л):',                                                 // app.jsxi:121
			'<input id="details_fuelPrice" type="number" min="0" step="0.1"></input>'
		], 
		function (arg){                                                            // app.jsxi:123
			var distance = d.find('#details_distance').val() || null;
			
			var consumption = d.find('#details_consumption').val() || null;
			
			var fuelPrice = d.find('#details_fuelPrice').val() || null;
			return Data.updateDetails({                                            // app.jsxi:128
				distance: distance,                                                // app.jsxi:128
				consumption: consumption,                                          // app.jsxi:129
				fuelPrice: fuelPrice
			});
		});
	
	d.find('#details_distance').val(o(currentShift.details.distance || '')).on('keydown', 
		function (arg){                                                            // app.jsxi:133
			if (arg.keyCode === 13){                                               // app.jsxi:134
				d.find('#details_consumption')[0].select();                        // app.jsxi:135
			}
		})[0].select();                                                            // app.jsxi:137
	d.find('#details_consumption').val(o(currentShift.details.consumption || localStorage.lastConsumption || '')).on('change', 
		function (arg){                                                            // app.jsxi:139
			localStorage.lastConsumption = this.value;                             // app.jsxi:140
		}).on('keydown',                                                           // app.jsxi:141
		function (arg){                                                            // app.jsxi:141
			if (arg.keyCode === 13){                                               // app.jsxi:142
				d.find('#details_fuelPrice')[0].select();                          // app.jsxi:143
			}
		});
	d.find('#details_fuelPrice').val(o(currentShift.details.fuelPrice || localStorage.lastFuelPrice || '')).on('change', 
		function (arg){                                                            // app.jsxi:147
			localStorage.lastFuelPrice = this.value;                               // app.jsxi:148
		}).on('keydown',                                                           // app.jsxi:149
		function (arg){                                                            // app.jsxi:149
			var __;
			
			if (arg.keyCode === 13){                                               // app.jsxi:150
				(__ = d.find('[data-id="dialog-ok"]')[0],                          // app.jsxi:151
					__[__ instanceof SectionAbstract ? '__click' : 'click']).call(__);
			}
		});
};
SectionEdit.prototype.finishShift = function (){                                   // app.jsxi:156
	var currentShift = Data.getCurrentShift();
	
	if (currentShift == null)                                                      // app.jsxi:158
		return;
	
	function step1(){                                                              // app.jsxi:160
		var d = new Dialog('Завершить смену',                                      // app.jsxi:161
			[ 'Вы уверены?' ], 
			function (arg){                                                        // app.jsxi:163
				if (currentShift.jobs.length === 0){                               // app.jsxi:164
					step2();                                                       // app.jsxi:165
				} else {
					step3();                                                       // app.jsxi:167
				}
			}).setButton('Да');                                                    // app.jsxi:169
		
		d.find('[data-id="dialog-ok"]').addClass('finish');                        // app.jsxi:170
	}
	
	function step2(){                                                              // app.jsxi:173
		step3();                                                                   // app.jsxi:175
	}
	
	function step3(){                                                              // app.jsxi:178
		var shift = Data.finishShift();
		
		if (!shift)                                                                // app.jsxi:180
			return;
		
		var summary = Data.getShiftSummary(shift);
		
		new Dialog('Конец смены',                                                  // app.jsxi:184
			[
				'<div class="div_sum_entry div_sum_entry_money" data-value="' + o(summary.order) + '">Заказы:</div>', 
				'<div class="div_sum_entry div_sum_entry_money" data-value="' + o(summary.tip) + '">Чаевые:</div>', 
				'<div class="div_sum_entry div_sum_entry_money" data-value="' + o(summary.hand) + '">С руки:</div>', 
				'<div class="div_sum_entry div_sum_entry_money" data-value="' + o(- summary.fuelPrice) + '">Топливо:</div>', 
				'<hr>',                                                            // app.jsxi:189
				'<div class="div_sum_entry div_sum_entry_money" data-value="' + o(summary.result) + '">Итого:</div>'
			]);
	}
	
	step1();                                                                       // app.jsxi:194
};
SectionEdit.prototype.updateCurrentShift = function (currentShift){                // app.jsxi:197
	if (currentShift == null){                                                     // app.jsxi:198
		this.__mode('init');
		return;
	}
	
	this.__mode('work');
	this.__$node.find('#section_edit_current_shift').text('Работа начата в ' + t(currentShift.timestamp));
};
SectionEdit.prototype.updateCurrentShiftJobs = function (currentShift){            // app.jsxi:207
	if (currentShift == null)                                                      // app.jsxi:208
		return;
	
	var l = currentShift.jobs.length;
	
	var i = currentShift.jobs.reduce(function (a, b){                              // app.jsxi:211
		return a + Data.getJobIncome(b);                                           // app.jsxi:211
	}, 
	0);
	
	this.__$node.find('#section_edit_jobs_number').toggle(l > 0).text('Выполнен' + l.postfix('', 'о', 'о') + ' ' + l.toLongString() + ' заказ' + l.postfix('', 'а', 'ов') + ',' + (' заработан' + i.postfix('', 'о', 'о') + ' ' + o(i) + ' рубл' + i.postfix('ь', 'я', 'ей')));
	this.__$node.find('#section_edit_jobs_list_empty').toggle(l === 0);            // app.jsxi:216
	this.__$node.find('#section_edit_jobs_list').html(currentShift.jobs.map(function (arg){
		return '<div class=\"section_edit_job_entry\"><p>' + ('Сумма: ' + o(arg.sum) + ' ₽, ' + (arg.tip > 0 ? 'чаевые: ' + o(arg.tip) + ' ₽, ' : '') + (arg.percent === 1 ? 'с руки' : o(arg.percent * 100) + '%')) + '</p><p class=\"p_small\">' + t(arg.timestamp) + '</p></div>';
	}).join(''));                                                                  // app.jsxi:222
};
SectionEdit.prototype.updateCurrentShiftDetails = function (currentShift){         // app.jsxi:226
	if (currentShift == null)                                                      // app.jsxi:227
		return;
	
	this.__$node.find('#section_edit_finish').toggle(currentShift.ready);          // app.jsxi:229
	this.__$node.find('#section_edit_details, #section_edit_finish').toggleClass('halfwidth', currentShift.ready);
};

/* Class "SectionView" declaration */
function SectionView(){                                                            // app.jsxi:234
	var __that = this;
	
	SectionAbstract.call(this, 
		'section_view');
	this.__mode('loading');
	Data.on('archive.loading:start',                                               // app.jsxi:239
		function (arg){                                                            // app.jsxi:239
			return __that.__mode('loading');
		});
	Data.on('archive.loading:finish',                                              // app.jsxi:240
		function (arg){                                                            // app.jsxi:240
			return __that.__mode(Data.getArchive().length === 0 ? 'empty' : 'view');
		});
	Data.on('archive.loading',                                                     // app.jsxi:241
		__bindOnce(this, 
			'__SectionView_onLoading'));
	Data.on('archive',                                                             // app.jsxi:243
		__bindOnce(this, 
			'__SectionView_updateTable'));
	Data.on('stats',                                                               // app.jsxi:244
		__bindOnce(this, 
			'__SectionView_updateStats'));
	this.__click('shifts_list',                                                    // app.jsxi:246
		__bindOnce(this, 
			'__SectionView_shiftListClick'));
	this.__$node.find('#section_view_stats, #section_view_charts').hide();         // app.jsxi:248
	this.__$node.find('#section_view_view_mode').change(function (arg){            // app.jsxi:249
		__that.__$node.find('#section_view_shifts_list, #section_view_stats, #section_view_charts').hide();
		__that.__$node.find('#section_view_' + this.value).show();                 // app.jsxi:251
		
		if (this.value === 'charts'){                                              // app.jsxi:253
			__that.__SectionView_updateCharts();
		}
	});
}
__prototypeExtend(SectionView, 
	SectionAbstract);
SectionView.prototype.__SectionView_onLoading = function (pos, max){               // app.jsxi:259
	this.__node.querySelector('#section_view_loading_progressbar').style.width = 100 * pos / max + '%';
};
SectionView.prototype.__SectionView_updateTable = function (archive){              // app.jsxi:263
	var l = archive.length;
	
	this.__mode(l === 0 ? 'empty' : 'view');
	this.__$node.find('#section_view_shifts_number').toggle(l > 0).text('Завершен' + l.postfix('а', 'о', 'о') + ' ' + l.toLongString(2) + ' смен' + l.postfix('а', 'ы', ''));
	
	var m = this.__$node.find('#section_view_view_mode').toggle(l > 1);            // app.jsxi:269
	
	if (l < 2 && m.val() !== 'shifts_list'){                                       // app.jsxi:270
		m.val('shifts_list');                                                      // app.jsxi:271
		this.__$node.find('#section_view_stats, #section_view_charts').hide();     // app.jsxi:272
		this.__$node.find('#section_view_shifts_list').show();                     // app.jsxi:273
	}
	
	this.__node.querySelector('#section_view_shifts_list').innerHTML = archive.map(function (arg){
		var l = arg.data.jobs.length, e = arg.summary.result;
		return '<div data-id="' + arg[arg instanceof SectionAbstract ? 'id' : 'id'] + '" class="section_view_shift_entry"><p>' + (o(l) + ' заказ' + l.postfix('', 'а', 'ов') + ', ' + o(e) + ' рубл' + e.postfix('ь', 'я', 'ей')) + '</p><p class="p_small">' + d(arg.data.timestamp) + '</p></div>';
	}).join('');                                                                   // app.jsxi:284
};
SectionView.prototype.__SectionView_updateStats = function (stats){                // app.jsxi:287
	function t(n){                                                                 // app.jsxi:288
		var t = Math.round(n / 60e3);
		
		var m = t % 60;
		
		var s = m + ' минут' + m.postfix('а', 'ы', '');
		
		var h = Math.floor(t / 60 % 24);
		
		if (h === 0)                                                               // app.jsxi:294
			return s;                                                              // app.jsxi:294
		
		s = h + ' час' + h.postfix('', 'а', 'ов') + ' ' + s;                       // app.jsxi:295
		
		var d = Math.floor(t / 60 / 60);
		
		if (d === 0)                                                               // app.jsxi:298
			return s;                                                              // app.jsxi:298
		
		s = d + ' д' + d.postfix('ень', 'ня', 'ней') + ' ' + s;                    // app.jsxi:299
		return s;                                                                  // app.jsxi:301
	}
	
	this.__node.querySelector('#section_view_stats').innerHTML = '               \n' + ('<div class="div_sum_entry" data-value="' + o(stats.jobs) + '">Заказов выполнено:</div>' + ('<div class="div_sum_entry" data-value="' + o(stats.jobsHand) + ' (' + o(100 * stats.jobsHand / stats.jobs) + '%)">Из них с руки:</div>') + ('<div class="div_sum_entry" data-value="' + o(stats.distance) + ' км">Пройдено:</div>') + ('<div class="div_sum_entry" data-value="' + o(stats.fuel) + ' л">Топлива потрачено:</div>') + ('<div class="div_sum_entry" data-value="' + t(stats.time) + '">Общее время:</div>')) + '\n<h6>Финансы</h6>\n' + ('<div class="div_sum_entry div_sum_entry_money" data-value="' + o(stats.order) + '">На заказах:</div>' + ('<div class="div_sum_entry div_sum_entry_money" data-value="' + o(- stats.lost) + '">Не считая отданных сервисам:</div>') + ('<div class="div_sum_entry div_sum_entry_money" data-value="' + o(stats.hand) + '">С руки:</div>') + ('<div class="div_sum_entry div_sum_entry_money" data-value="' + o(stats.tip) + '">Чаевые:</div>') + ('<div class="div_sum_entry div_sum_entry_money" data-value="' + o(stats.income) + '">Итого доход:</div>') + ('<div class="div_sum_entry div_sum_entry_money" data-value="' + o(- stats.fuelPrice) + '">На топливо ушло:</div>') + ('<div class="div_sum_entry div_sum_entry_money" data-value="' + o(stats.result) + '">В результате:</div>')) + '\n<h6>Усреднённое</h6>\n' + ('<div class="div_sum_entry div_sum_entry_money" data-value="' + o(stats.tip / stats.jobsOrder) + '">Размер чаевых:</div>' + ('<div class="div_sum_entry" data-value="' + o(stats.distance / stats.time * 3600e3) + ' км/ч">Скорость:</div>') + ('<div class="div_sum_entry" data-value="' + o(stats.fuel / stats.distance * 100) + ' л/100 км">Расход топлива:</div>')) + '\n';
};
SectionView.prototype.__SectionView_updateCharts = function (){                    // app.jsxi:332
	var archive = Data.getArchive();
	
	if (!archive)                                                                  // app.jsxi:334
		return;
	
	$('.line-legend').remove();                                                    // app.jsxi:336
	Chart.defaults.global = {                                                      // app.jsxi:338
		showScale: true,                                                           // app.jsxi:338
		scaleOverride: false,                                                      // app.jsxi:340
		scaleSteps: null,                                                          // app.jsxi:341
		scaleStepWidth: null,                                                      // app.jsxi:343
		scaleStartValue: null,                                                     // app.jsxi:344
		scaleLineColor: 'rgba(0,0,0,.1)',                                          // app.jsxi:346
		scaleLineWidth: 1,                                                         // app.jsxi:347
		scaleShowLabels: true,                                                     // app.jsxi:348
		scaleLabel: '<%=value%>',                                                  // app.jsxi:350
		scaleIntegersOnly: true,                                                   // app.jsxi:351
		scaleBeginAtZero: false,                                                   // app.jsxi:352
		scaleFontFamily: 'Roboto, sans-serif',                                     // app.jsxi:354
		scaleFontSize: 12,                                                         // app.jsxi:355
		scaleFontStyle: 'normal',                                                  // app.jsxi:356
		scaleFontColor: '#666',                                                    // app.jsxi:357
		responsive: true,                                                          // app.jsxi:359
		maintainAspectRatio: true,                                                 // app.jsxi:360
		showTooltips: true,                                                        // app.jsxi:362
		customTooltips: false,                                                     // app.jsxi:363
		tooltipEvents: [ 'mousemove', 'touchstart', 'touchmove' ],                 // app.jsxi:364
		tooltipFillColor: 'rgba(0,0,0,0.8)',                                       // app.jsxi:365
		tooltipFontFamily: 'Roboto, sans-serif',                                   // app.jsxi:366
		tooltipFontSize: 14,                                                       // app.jsxi:367
		tooltipFontStyle: 'normal',                                                // app.jsxi:368
		tooltipFontColor: '#fff',                                                  // app.jsxi:369
		tooltipTitleFontFamily: 'Roboto, sans-serif',                              // app.jsxi:370
		tooltipTitleFontSize: 14,                                                  // app.jsxi:371
		tooltipTitleFontStyle: 'bold',                                             // app.jsxi:372
		tooltipTitleFontColor: '#fff',                                             // app.jsxi:373
		tooltipYPadding: 6,                                                        // app.jsxi:374
		tooltipXPadding: 6,                                                        // app.jsxi:375
		tooltipCaretSize: 8,                                                       // app.jsxi:376
		tooltipCornerRadius: 2,                                                    // app.jsxi:377
		tooltipXOffset: 10,                                                        // app.jsxi:378
		tooltipTemplate: '<%if (label){%><%=label%>: <%}%><%= value %>',           // app.jsxi:379
		multiTooltipTemplate: '<%= value %>'
	};
	
	var ctx = document.getElementById('section_view_chart_result').getContext("2d");
	
	var chart = new Chart(ctx).Line({                                              // app.jsxi:384
		labels: archive.map(function (arg){                                        // app.jsxi:384
			return d(arg.data.timestamp);                                          // app.jsxi:385
		}), 
		datasets: [                                                                // app.jsxi:386
			{                                                                      // app.jsxi:386
				label: 'Всего',                                                    // app.jsxi:386
				fillColor: "rgba(60,220,60,0.2)",                                  // app.jsxi:389
				strokeColor: "rgba(60,220,60,1)",                                  // app.jsxi:390
				pointColor: "rgba(60,220,60,1)",                                   // app.jsxi:391
				pointStrokeColor: "#fff",                                          // app.jsxi:392
				pointHighlightFill: "#fff",                                        // app.jsxi:393
				pointHighlightStroke: "rgba(220,220,220,1)",                       // app.jsxi:394
				data: archive.map(function (arg){                                  // app.jsxi:395
					return + arg.summary.result.toFixed(2);                        // app.jsxi:395
				})
			}, 
			{
				label: 'С руки',                                                   // app.jsxi:397
				fillColor: "rgba(220,220,60,0.2)",                                 // app.jsxi:398
				strokeColor: "rgba(220,220,60,1)",                                 // app.jsxi:399
				pointColor: "rgba(220,220,60,1)",                                  // app.jsxi:400
				pointStrokeColor: "#fff",                                          // app.jsxi:401
				pointHighlightFill: "#fff",                                        // app.jsxi:402
				pointHighlightStroke: "rgba(220,220,220,1)",                       // app.jsxi:403
				data: archive.map(function (arg){                                  // app.jsxi:404
					return + arg.summary.hand.toFixed(2);                          // app.jsxi:404
				})
			}, 
			{
				label: 'Чаевые',                                                   // app.jsxi:406
				fillColor: "rgba(220,220,220,0.2)",                                // app.jsxi:407
				strokeColor: "rgba(220,220,220,1)",                                // app.jsxi:408
				pointColor: "rgba(220,220,220,1)",                                 // app.jsxi:409
				pointStrokeColor: "#fff",                                          // app.jsxi:410
				pointHighlightFill: "#fff",                                        // app.jsxi:411
				pointHighlightStroke: "rgba(220,220,220,1)",                       // app.jsxi:412
				data: archive.map(function (arg){                                  // app.jsxi:413
					return + arg.summary.tip.toFixed(2);                           // app.jsxi:413
				})
			}, 
			{
				label: 'Топливо',                                                  // app.jsxi:415
				fillColor: "rgba(220,60,60,0.2)",                                  // app.jsxi:416
				strokeColor: "rgba(220,60,60,1)",                                  // app.jsxi:417
				pointColor: "rgba(220,60,60,1)",                                   // app.jsxi:418
				pointStrokeColor: "#fff",                                          // app.jsxi:419
				pointHighlightFill: "#fff",                                        // app.jsxi:420
				pointHighlightStroke: "rgba(220,220,220,1)",                       // app.jsxi:421
				data: archive.map(function (arg){                                  // app.jsxi:422
					return + arg.summary.fuelPrice.toFixed(2);                     // app.jsxi:422
				})
			}
		]
	}, 
	{
		scaleShowXLabels: false,                                                   // app.jsxi:426
		scaleBeginAtZero: true,                                                    // app.jsxi:427
		bezierCurveTension: 0.2
	});
	
	$(chart.generateLegend()).insertAfter(document.getElementById('section_view_chart_result'));
};
SectionView.prototype.__SectionView_shiftListClick = function (arg){               // app.jsxi:434
	var entry = $(arg.target).closest('.section_view_shift_entry');
	
	if (!entry[0])                                                                 // app.jsxi:436
		return;
	
	var shift = Data.getArchiveById(entry.data('id'));
	
	if (!shift)                                                                    // app.jsxi:439
		return;
	
	new Dialog('Смена',                                                            // app.jsxi:441
		[
			'<div class="div_sum_entry" data-value="' + d(shift.data.timestamp) + '">Начало:</div>', 
			'<div class="div_sum_entry" data-value="' + d(shift.data.finished) + '">Завершение:</div>', 
			'<div class="div_sum_entry" data-value="' + t(shift.data.finished - shift.data.timestamp) + '">Длительность:</div>', 
			'<div class="div_sum_entry" data-value="' + o(shift.data.jobs.length) + '">Выполнено заказов:</div>', 
			'<hr>',                                                                // app.jsxi:447
			'<div class="div_sum_entry div_sum_entry_money" data-value="' + o(shift.summary.order) + '">Заказы:</div>', 
			'<div class="div_sum_entry div_sum_entry_money" data-value="' + o(shift.summary.tip) + '">Чаевые:</div>', 
			'<div class="div_sum_entry div_sum_entry_money" data-value="' + o(shift.summary.hand) + '">С руки:</div>', 
			'<div class="div_sum_entry div_sum_entry_money" data-value="' + o(- shift.summary.fuelPrice) + '">Топливо:</div>', 
			'<hr>',                                                                // app.jsxi:453
			'<div class="div_sum_entry div_sum_entry_money" data-value="' + o(shift.summary.result) + '">Итого:</div>'
		]);
};
SectionView.prototype.show = function (){                                          // app.jsxi:458
	SectionAbstract.prototype.show.call(this);                                     // app.jsxi:1
	Data.loadArchive();                                                            // app.jsxi:460
};

/* Class "App" declaration */
var App = (function (){                                                            // app.jsxi:464
	var App = function (){}, 
		sEdit, sView;
	
	App.NAME = 'Такси-Помощник';                                                   // app.jsxi:465
	App.VERSION = "0.2.39";                                                        // app.jsxi:466
	
	function navigate(page){                                                       // app.jsxi:470
		switch (page){                                                             // app.jsxi:471
			case 'edit':                                                           // app.jsxi:472
				sEdit.show();                                                      // app.jsxi:473
				sView.hide();                                                      // app.jsxi:474
				
				break;
			case 'view':                                                           // app.jsxi:477
				sEdit.hide();                                                      // app.jsxi:478
				sView.show();                                                      // app.jsxi:479
				
				break;
		}
	}
	
	(function (){                                                                  // app.jsxi:484
		sEdit = new SectionEdit();                                                 // app.jsxi:485
		sView = new SectionView();                                                 // app.jsxi:486
		Navigation.on('navigate', navigate);                                       // app.jsxi:488
		$(function (arg){                                                          // app.jsxi:490
			document.body.style.display = null;                                    // app.jsxi:491
			setTimeout(function (arg){                                             // app.jsxi:493
				scrollTo(0, 1);                                                    // app.jsxi:494
			}, 
			50);
		});
	})();
	return App;
})();

/* Class "Menu" declaration */
function Menu(){                                                                   // app.jsxi:500
	var __that = this;
	
	this.__Menu_node = document.getElementById('ui_menu');                         // app.jsxi:504
	this.__Menu_$node = $(this.__Menu_node);                                       // app.jsxi:505
	this.__Menu_$node.on('click',                                                  // app.jsxi:507
		function (arg){                                                            // app.jsxi:507
			if (arg.target.id === 'ui_menu'){                                      // app.jsxi:508
				__that.hide();
			}
		});
	this.__Menu_$node.find('button').on('click',                                   // app.jsxi:513
		function (arg){                                                            // app.jsxi:513
			switch (arg.target.id){                                                // app.jsxi:514
				case 'ui_menu_item_about':                                         // app.jsxi:515
					__that.__Menu_clickAbout();
					
					break;
			}
			
			__that.hide();
		});
}
Menu.prototype.__Menu_clickAbout = function (){                                    // app.jsxi:524
	new Dialog(App.NAME,                                                           // app.jsxi:525
		[
			'<div class="div_sum_entry" data-value="' + App.VERSION + '">Версия:</div>'
		]);
};
Menu.prototype.show = function (){                                                 // app.jsxi:530
	if (this.__Menu_showed)
		return;
	
	this.__Menu_$node.addClass('ui_menu_active');                                  // app.jsxi:532
	this.__Menu_showed = true;
	Navigation.sub();                                                              // app.jsxi:535
	Navigation.on('subback',                                                       // app.jsxi:536
		__bindOnce(this, 
			'hide'));
};
Menu.prototype.hide = function (){                                                 // app.jsxi:539
	if (!this.__Menu_showed)
		return;
	
	this.__Menu_$node.removeClass('ui_menu_active');                               // app.jsxi:541
	this.__Menu_showed = false;
	Navigation.off('subback',                                                      // app.jsxi:544
		__bindOnce(this, 
			'hide'));
};
Menu.prototype.toggle = function (){                                               // app.jsxi:547
	if (this.__Menu_showed)
		this.hide();
	else
		this.show();
};

/* Class "Tabs" declaration */
var Tabs = (function (){                                                           // app.jsxi:552
	var Tabs = function (){}, 
		$node, menu;
	
	function update(page){                                                         // app.jsxi:555
		$node.find('.ui_tabbar_tab_active').removeClass('ui_tabbar_tab_active');   // app.jsxi:556
		$node.find('[data-href="#' + page + '"]').addClass('ui_tabbar_tab_active');
	}
	
	(function (){                                                                  // app.jsxi:560
		$node = $(document.getElementById('ui_tabbar'));                           // app.jsxi:561
		$node.find('a').on('click',                                                // app.jsxi:562
			function (arg){                                                        // app.jsxi:562
				location.replace(this.getAttribute('data-href'));                  // app.jsxi:563
				return false;
			});
		menu = new Menu();                                                         // app.jsxi:567
		$node.find('#ui_tabbar_btn_menu').on('click',                              // app.jsxi:568
			function (arg){                                                        // app.jsxi:568
				menu.toggle();                                                     // app.jsxi:569
			});
		Navigation.on('navigate', update);                                         // app.jsxi:572
	})();
	return Tabs;
})();

/* Class "Adaptive" declaration */
var Adaptive = (function (){                                                       // adaptive.jsxi:7
	var Adaptive = function (){};
	
	function canv(c){                                                              // adaptive.jsxi:8
		c.style.width = (c.width = window.innerWidth - 40) + 'px';                 // adaptive.jsxi:9
		c.style.height = (c.height = 240) + 'px';                                  // adaptive.jsxi:10
	}
	
	function update(){                                                             // adaptive.jsxi:13
		document.getElementById('section_edit_jobs_list').style.height = window.innerHeight - 640 + 385 + 'px';
		document.getElementById('section_view_shifts_list').style.height = window.innerHeight - 640 + 515 + 'px';
		canv(document.getElementById('section_view_chart_result'));                // adaptive.jsxi:17
	}
	
	(function (){                                                                  // adaptive.jsxi:20
		window.onresize = update;                                                  // adaptive.jsxi:21
		$(update);                                                                 // adaptive.jsxi:22
	})();
	return Adaptive;
})();</script></body></html>
